{
  "language": "Solidity",
  "sources": {
    "contracts/lib/ERC20.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public  view returns (uint256);\r\n    function transfer(address to, uint256 value)  public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n contract ERC20 is ERC20Basic {\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals;\r\n    function allowance(address owner, address spender)  public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value)  public returns (bool);\r\n    function approve(address spender, uint256 value)  public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/platform/bondage/Bondage.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport '../../lib/lifecycle/Destructible.sol';\r\nimport '../../lib/ownership/Upgradable.sol';\r\nimport '../../lib/ERC20.sol';\r\nimport '../database/DatabaseInterface.sol';\r\nimport './currentCost/CurrentCostInterface.sol';\r\nimport './BondageInterface.sol';\r\n\r\ncontract Bondage is Destructible, BondageInterface, Upgradable {\r\n    DatabaseInterface public db;\r\n\r\n    event Bound(\r\n        address indexed holder,\r\n        address indexed oracle,\r\n        bytes32 indexed endpoint,\r\n        uint256 numZap,\r\n        uint256 numDots\r\n    );\r\n    event Unbound(\r\n        address indexed holder,\r\n        address indexed oracle,\r\n        bytes32 indexed endpoint,\r\n        uint256 numDots\r\n    );\r\n    event Escrowed(\r\n        address indexed holder,\r\n        address indexed oracle,\r\n        bytes32 indexed endpoint,\r\n        uint256 numDots\r\n    );\r\n    event Released(\r\n        address indexed holder,\r\n        address indexed oracle,\r\n        bytes32 indexed endpoint,\r\n        uint256 numDots\r\n    );\r\n    event Returned(\r\n        address indexed holder,\r\n        address indexed oracle,\r\n        bytes32 indexed endpoint,\r\n        uint256 numDots\r\n    );\r\n\r\n    CurrentCostInterface currentCost;\r\n    ERC20 token;\r\n\r\n    address public arbiterAddress;\r\n    address public dispatchAddress;\r\n\r\n    // For restricting dot escrow/transfer method calls to Dispatch and Arbiter\r\n    modifier operatorOnly() {\r\n        require(\r\n            msg.sender == arbiterAddress || msg.sender == dispatchAddress,\r\n            'Error: Operator Only Error'\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Initialize Storage, Token, and CurrentCost Contracts\r\n    constructor(address c) public Upgradable(c) {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        address databaseAddress = coordinator.getContract('DATABASE');\r\n        db = DatabaseInterface(databaseAddress);\r\n        arbiterAddress = coordinator.getContract('ARBITER');\r\n        dispatchAddress = coordinator.getContract('DISPATCH');\r\n        token = ERC20(coordinator.getContract('ZAP_TOKEN'));\r\n        currentCost = CurrentCostInterface(\r\n            coordinator.getContract('CURRENT_COST')\r\n        );\r\n    }\r\n\r\n    /// @dev will bond to an oracle\r\n    /// @return bound : total ZAP bound to oracle\r\n    function bond(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external returns (uint256 bound) {\r\n        bound = _bond(msg.sender, oracleAddress, endpoint, numDots);\r\n        emit Bound(msg.sender, oracleAddress, endpoint, bound, numDots);\r\n    }\r\n\r\n    /// @return unbound : total ZAP unbound from oracle\r\n    function unbond(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external returns (uint256 unbound) {\r\n        unbound = _unbond(msg.sender, oracleAddress, endpoint, numDots);\r\n        emit Unbound(msg.sender, oracleAddress, endpoint, numDots);\r\n    }\r\n\r\n    /// @dev will bond to an oracle on behalf of some holder\r\n    /// @return boundZap : total ZAP bound to oracle\r\n    function delegateBond(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external returns (uint256 boundZap) {\r\n        boundZap = _bond(holderAddress, oracleAddress, endpoint, numDots);\r\n        emit Bound(holderAddress, oracleAddress, endpoint, boundZap, numDots);\r\n    }\r\n\r\n    /// @dev Move numDots dots from provider-requester to bondage according to\r\n    /// data-provider address, holder address, and endpoint specifier (ala 'smart_contract')\r\n    /// Called only by Dispatch or Arbiter Contracts\r\n    function escrowDots(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external operatorOnly returns (bool success) {\r\n        uint256 boundDots = getBoundDots(\r\n            holderAddress,\r\n            oracleAddress,\r\n            endpoint\r\n        );\r\n        require(numDots <= boundDots, 'Error: Not enough dots bound');\r\n        updateEscrow(holderAddress, oracleAddress, endpoint, numDots, 'add');\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, 'sub');\r\n        emit Escrowed(holderAddress, oracleAddress, endpoint, numDots);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer N dots from fromAddress to destAddress.\r\n    /// Called only by Disptach or Arbiter Contracts\r\n    /// In smart contract endpoint, occurs per satisfied request.\r\n    /// In socket endpoint called on termination of subscription.\r\n    function releaseDots(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external operatorOnly returns (bool success) {\r\n        uint256 numEscrowed = getNumEscrow(\r\n            holderAddress,\r\n            oracleAddress,\r\n            endpoint\r\n        );\r\n        require(numDots <= numEscrowed, 'Error: Not enough dots Escrowed');\r\n        updateEscrow(holderAddress, oracleAddress, endpoint, numDots, 'sub');\r\n        updateBondValue(oracleAddress, oracleAddress, endpoint, numDots, 'add');\r\n        emit Released(holderAddress, oracleAddress, endpoint, numDots);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer N dots from destAddress to fromAddress.\r\n    /// Called only by Disptach or Arbiter Contracts\r\n    /// In smart contract endpoint, occurs per satisfied request.\r\n    /// In socket endpoint called on termination of subscription.\r\n    function returnDots(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external operatorOnly returns (bool success) {\r\n        uint256 numEscrowed = getNumEscrow(\r\n            holderAddress,\r\n            oracleAddress,\r\n            endpoint\r\n        );\r\n        require(numDots <= numEscrowed, 'Error: Not enough dots escrowed');\r\n        updateEscrow(holderAddress, oracleAddress, endpoint, numDots, 'sub');\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, 'add');\r\n        emit Returned(holderAddress, oracleAddress, endpoint, numDots);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Calculate quantity of tokens required for specified amount of dots\r\n    /// for endpoint defined by endpoint and data provider defined by oracleAddress\r\n    function calcZapForDots(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) external view returns (uint256 numZap) {\r\n        uint256 issued = getDotsIssued(oracleAddress, endpoint);\r\n        return\r\n            currentCost._costOfNDots(\r\n                oracleAddress,\r\n                endpoint,\r\n                issued + 1,\r\n                numDots - 1\r\n            );\r\n    }\r\n\r\n    /// @dev Get the current cost of a dot.\r\n    /// @param endpoint specifier\r\n    /// @param oracleAddress data-provider\r\n    /// @param totalBound current number of dots\r\n    function currentCostOfDot(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 totalBound\r\n    ) public view returns (uint256 cost) {\r\n        return\r\n            currentCost._currentCostOfDot(oracleAddress, endpoint, totalBound);\r\n    }\r\n\r\n    /// @dev Get issuance limit of dots\r\n    /// @param endpoint specifier\r\n    /// @param oracleAddress data-provider\r\n    function dotLimit(address oracleAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (uint256 limit)\r\n    {\r\n        return currentCost._dotLimit(oracleAddress, endpoint);\r\n    }\r\n\r\n    /// @return total ZAP held by contract\r\n    function getZapBound(address oracleAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return getNumZap(oracleAddress, endpoint);\r\n    }\r\n\r\n    function _bond(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) private returns (uint256) {\r\n        address broker = getEndpointBroker(oracleAddress, endpoint);\r\n\r\n        if (broker != address(0)) {\r\n            require(\r\n                msg.sender == broker,\r\n                'Error: Only the broker has access to this function'\r\n            );\r\n        }\r\n\r\n        // This also checks if oracle is registered w/ an initialized curve\r\n        uint256 issued = getDotsIssued(oracleAddress, endpoint);\r\n\r\n        require(\r\n            issued + numDots <= dotLimit(oracleAddress, endpoint),\r\n            'Error: Dot limit exceeded'\r\n        );\r\n\r\n        uint256 numZap = currentCost._costOfNDots(\r\n            oracleAddress,\r\n            endpoint,\r\n            issued + 1,\r\n            numDots - 1\r\n        );\r\n        //require(token.balancnumDots)\r\n        // User must have approved contract to transfer working ZAP\r\n        require(token.balanceOf(msg.sender) >= numZap, 'cost in dots');\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), numZap),\r\n            'Error: User must have approved contract to transfer ZAP'\r\n        );\r\n\r\n        if (!isProviderInitialized(holderAddress, oracleAddress)) {\r\n            setProviderInitialized(holderAddress, oracleAddress);\r\n            addHolderOracle(holderAddress, oracleAddress);\r\n        }\r\n\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, 'add');\r\n        updateTotalIssued(oracleAddress, endpoint, numDots, 'add');\r\n        updateTotalBound(oracleAddress, endpoint, numZap, 'add');\r\n\r\n        return numZap;\r\n    }\r\n\r\n    function _unbond(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots\r\n    ) private returns (uint256 numZap) {\r\n        address broker = getEndpointBroker(oracleAddress, endpoint);\r\n\r\n        if (broker != address(0)) {\r\n            require(\r\n                msg.sender == broker,\r\n                'Error: Only the broker has access to this function'\r\n            );\r\n        }\r\n\r\n        // Make sure the user has enough to bond with some additional sanity checks\r\n        uint256 amountBound = getBoundDots(\r\n            holderAddress,\r\n            oracleAddress,\r\n            endpoint\r\n        );\r\n        require(amountBound >= numDots, 'Error: Not enough dots bonded');\r\n        require(numDots > 0, 'Error: Dots to unbond must be more than zero');\r\n\r\n        // Get the value of the dots\r\n        uint256 issued = getDotsIssued(oracleAddress, endpoint);\r\n        numZap = currentCost._costOfNDots(\r\n            oracleAddress,\r\n            endpoint,\r\n            issued + 1 - numDots,\r\n            numDots - 1\r\n        );\r\n\r\n        // Update the storage values\r\n        updateTotalBound(oracleAddress, endpoint, numZap, 'sub');\r\n        updateTotalIssued(oracleAddress, endpoint, numDots, 'sub');\r\n        updateBondValue(holderAddress, oracleAddress, endpoint, numDots, 'sub');\r\n\r\n        // Do the transfer\r\n        require(token.transfer(msg.sender, numZap), 'Error: Transfer failed');\r\n\r\n        return numZap;\r\n    }\r\n\r\n    /**** Get Methods ****/\r\n    function isProviderInitialized(address holderAddress, address oracleAddress)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            db.getNumber(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        'holders',\r\n                        holderAddress,\r\n                        'initialized',\r\n                        oracleAddress\r\n                    )\r\n                )\r\n            ) == 1\r\n                ? true\r\n                : false;\r\n    }\r\n\r\n    /// @dev get broker address for endpoint\r\n    function getEndpointBroker(address oracleAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        // bytes32 result=db.getBytes32(keccak256(abi.encodePacked('oracles', oracleAddress, endpoint, 'broker')));\r\n\r\n        return\r\n            address(\r\n                uint160(\r\n                    bytes20(\r\n                        db.getBytes32(\r\n                            keccak256(\r\n                                abi.encodePacked(\r\n                                    'oracles',\r\n                                    oracleAddress,\r\n                                    endpoint,\r\n                                    'broker'\r\n                                )\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function getNumEscrow(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint\r\n    ) public view returns (uint256) {\r\n        return\r\n            db.getNumber(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        'escrow',\r\n                        holderAddress,\r\n                        oracleAddress,\r\n                        endpoint\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function getNumZap(address oracleAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            db.getNumber(\r\n                keccak256(\r\n                    abi.encodePacked('totalBound', oracleAddress, endpoint)\r\n                )\r\n            );\r\n    }\r\n\r\n    function getDotsIssued(address oracleAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            db.getNumber(\r\n                keccak256(\r\n                    abi.encodePacked('totalIssued', oracleAddress, endpoint)\r\n                )\r\n            );\r\n    }\r\n\r\n    function getBoundDots(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint\r\n    ) public view returns (uint256) {\r\n        return\r\n            db.getNumber(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        'holders',\r\n                        holderAddress,\r\n                        'bonds',\r\n                        oracleAddress,\r\n                        endpoint\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function getIndexSize(address holderAddress)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            db.getAddressArrayLength(\r\n                keccak256(\r\n                    abi.encodePacked('holders', holderAddress, 'oracleList')\r\n                )\r\n            );\r\n    }\r\n\r\n    function getOracleAddress(address holderAddress, uint256 index)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return\r\n            db.getAddressArrayIndex(\r\n                keccak256(\r\n                    abi.encodePacked('holders', holderAddress, 'oracleList')\r\n                ),\r\n                index\r\n            );\r\n    }\r\n\r\n    /**** Set Methods ****/\r\n    function addHolderOracle(address holderAddress, address oracleAddress)\r\n        internal\r\n    {\r\n        db.pushAddressArray(\r\n            keccak256(abi.encodePacked('holders', holderAddress, 'oracleList')),\r\n            oracleAddress\r\n        );\r\n    }\r\n\r\n    function setProviderInitialized(\r\n        address holderAddress,\r\n        address oracleAddress\r\n    ) internal {\r\n        db.setNumber(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    'holders',\r\n                    holderAddress,\r\n                    'initialized',\r\n                    oracleAddress\r\n                )\r\n            ),\r\n            1\r\n        );\r\n    }\r\n\r\n    function updateEscrow(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots,\r\n        bytes32 op\r\n    ) internal {\r\n        uint256 newEscrow = db.getNumber(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    'escrow',\r\n                    holderAddress,\r\n                    oracleAddress,\r\n                    endpoint\r\n                )\r\n            )\r\n        );\r\n\r\n        if (op == 'sub') {\r\n            newEscrow -= numDots;\r\n        } else if (op == 'add') {\r\n            newEscrow += numDots;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        db.setNumber(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    'escrow',\r\n                    holderAddress,\r\n                    oracleAddress,\r\n                    endpoint\r\n                )\r\n            ),\r\n            newEscrow\r\n        );\r\n    }\r\n\r\n    function updateBondValue(\r\n        address holderAddress,\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots,\r\n        bytes32 op\r\n    ) internal {\r\n        uint256 bondValue = db.getNumber(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    'holders',\r\n                    holderAddress,\r\n                    'bonds',\r\n                    oracleAddress,\r\n                    endpoint\r\n                )\r\n            )\r\n        );\r\n\r\n        if (op == 'sub') {\r\n            bondValue -= numDots;\r\n        } else if (op == 'add') {\r\n            bondValue += numDots;\r\n        }\r\n\r\n        db.setNumber(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    'holders',\r\n                    holderAddress,\r\n                    'bonds',\r\n                    oracleAddress,\r\n                    endpoint\r\n                )\r\n            ),\r\n            bondValue\r\n        );\r\n    }\r\n\r\n    function updateTotalBound(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numZap,\r\n        bytes32 op\r\n    ) internal {\r\n        uint256 totalBound = db.getNumber(\r\n            keccak256(abi.encodePacked('totalBound', oracleAddress, endpoint))\r\n        );\r\n\r\n        if (op == 'sub') {\r\n            totalBound -= numZap;\r\n        } else if (op == 'add') {\r\n            totalBound += numZap;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('totalBound', oracleAddress, endpoint)),\r\n            totalBound\r\n        );\r\n    }\r\n\r\n    function updateTotalIssued(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 numDots,\r\n        bytes32 op\r\n    ) internal {\r\n        uint256 totalIssued = db.getNumber(\r\n            keccak256(abi.encodePacked('totalIssued', oracleAddress, endpoint))\r\n        );\r\n\r\n        if (op == 'sub') {\r\n            totalIssued -= numDots;\r\n        } else if (op == 'add') {\r\n            totalIssued += numDots;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('totalIssued', oracleAddress, endpoint)),\r\n            totalIssued\r\n        );\r\n    }\r\n}\r\n\r\n/*************************************** STORAGE ****************************************\r\n * 'holders', holderAddress, 'initialized', oracleAddress => {uint256} 1 -> provider-subscriber initialized, 0 -> not initialized\r\n * 'holders', holderAddress, 'bonds', oracleAddress, endpoint => {uint256} number of dots this address has bound to this endpoint\r\n * 'oracles', oracleAddress, endpoint, 'broker' => {address} address of endpoint broker, 0 if none\r\n * 'escrow', holderAddress, oracleAddress, endpoint => {uint256} amount of Zap that have been escrowed\r\n * 'totalBound', oracleAddress, endpoint => {uint256} amount of Zap bound to this endpoint\r\n * 'totalIssued', oracleAddress, endpoint => {uint256} number of dots issued by this endpoint\r\n * 'holders', holderAddress, 'oracleList' => {address[]} array of oracle addresses associated with this holder\r\n ****************************************************************************************/\r\n"
    },
    "contracts/lib/lifecycle/Destructible.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"../ownership/Ownable.sol\";\r\n\r\ncontract Destructible is Ownable {\r\n    function selfDestruct() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n"
    },
    "contracts/lib/ownership/Upgradable.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./ZapCoordinatorInterface.sol\";\r\n\r\n contract Upgradable {\r\n\r\n    address coordinatorAddr;\r\n    ZapCoordinatorInterface coordinator;\r\n\r\n    constructor(address c) public {\r\n        coordinatorAddr = c;\r\n        coordinator = ZapCoordinatorInterface(c);\r\n    }\r\n\r\n    function updateDependencies() external coordinatorOnly {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies()  internal;\r\n\r\n    modifier coordinatorOnly() {\r\n        require(msg.sender == coordinatorAddr, \"Error: Coordinator Only Function\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/platform/database/DatabaseInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"../../lib/ownership/Ownable.sol\";\r\n\r\n contract DatabaseInterface is Ownable {\r\n    function setStorageContract(address _storageContract, bool _allowed)  public;\r\n    /*** Bytes32 ***/\r\n    function getBytes32(bytes32 key) external  view returns(bytes32);\r\n    function setBytes32(bytes32 key, bytes32 value) external ;\r\n    /*** Number **/\r\n    function getNumber(bytes32 key) external  view returns(uint256);\r\n    function setNumber(bytes32 key, uint256 value) external ;\r\n    /*** Bytes ***/\r\n    function getBytes(bytes32 key) external  view returns(bytes memory);\r\n    function setBytes(bytes32 key, bytes calldata value) external ;\r\n    /*** String ***/\r\n    function getString(bytes32 key) external  view returns(string memory);\r\n    function setString(bytes32 key, string calldata value) external ;\r\n    /*** Bytes Array ***/\r\n    function getBytesArray(bytes32 key) external  view returns (bytes32[] memory);\r\n    function getBytesArrayIndex(bytes32 key, uint256 index) external  view returns (bytes32);\r\n    function getBytesArrayLength(bytes32 key) external  view returns (uint256);\r\n    function pushBytesArray(bytes32 key, bytes32 value) external ;\r\n    function setBytesArrayIndex(bytes32 key, uint256 index, bytes32 value) external ;\r\n    function setBytesArray(bytes32 key, bytes32[] calldata value) external ;\r\n    /*** Int Array ***/\r\n    function getIntArray(bytes32 key) external  view returns (int[] memory);\r\n    function getIntArrayIndex(bytes32 key, uint256 index) external  view returns (int);\r\n    function getIntArrayLength(bytes32 key) external  view returns (uint256);\r\n    function pushIntArray(bytes32 key, int value) external ;\r\n    function setIntArrayIndex(bytes32 key, uint256 index, int value) external ;\r\n    function setIntArray(bytes32 key, int[] calldata value) external ;\r\n    /*** Address Array ***/\r\n    function getAddressArray(bytes32 key) external  view returns (address[] memory );\r\n    function getAddressArrayIndex(bytes32 key, uint256 index) external  view returns (address);\r\n    function getAddressArrayLength(bytes32 key) external  view returns (uint256);\r\n    function pushAddressArray(bytes32 key, address value) external ;\r\n    function setAddressArrayIndex(bytes32 key, uint256 index, address value) external ;\r\n    function setAddressArray(bytes32 key, address[] calldata value) external ;\r\n}\r\n"
    },
    "contracts/platform/bondage/currentCost/CurrentCostInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract CurrentCostInterface {\r\n    function _currentCostOfDot(address, bytes32, uint256) public  view returns (uint256);\r\n    function _dotLimit(address, bytes32)  public view returns (uint256);\r\n    function _costOfNDots(address, bytes32, uint256, uint256)  public view returns (uint256);\r\n}\r\n"
    },
    "contracts/platform/bondage/BondageInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract BondageInterface {\r\n    function bond(address, bytes32, uint256) external  returns(uint256);\r\n    function unbond(address, bytes32, uint256) external  returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256) external  returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256) external  returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256) external  returns (bool);\r\n    function returnDots(address, address, bytes32, uint256) external  returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256) external  view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256) public  view returns (uint256);\r\n    function getDotsIssued(address, bytes32) public  view returns (uint256);\r\n    function getBoundDots(address, address, bytes32) public  view returns (uint256);\r\n    function getZapBound(address, bytes32) public  view returns (uint256);\r\n    function dotLimit( address, bytes32) public  view returns (uint256);\r\n}\r\n"
    },
    "contracts/lib/ownership/Ownable.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}"
    },
    "contracts/lib/ownership/ZapCoordinatorInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n contract ZapCoordinatorInterface is Ownable {\r\n    function addImmutableContract(string calldata contractName, address newAddress)  external;\r\n    function updateContract(string calldata contractName, address newAddress)  external;\r\n    function getContractName(uint index)  public view returns (string memory) ;\r\n    function getContract(string memory contractName)  public view returns (address);\r\n    function updateAllDependencies()  external;\r\n}\r\n"
    },
    "contracts/platform/dispatch/Dispatch.sol": {
      "content": "pragma solidity =0.5.16;\r\n// v1.0\r\n\r\nimport '../../lib/ownership/Upgradable.sol';\r\nimport '../../lib/lifecycle/Destructible.sol';\r\nimport '../../lib/platform/Client.sol';\r\nimport '../../lib/platform/OnChainProvider.sol';\r\nimport '../bondage/BondageInterface.sol';\r\nimport './DispatchInterface.sol';\r\nimport '../database/DatabaseInterface.sol';\r\n\r\ncontract Dispatch is Destructible, DispatchInterface, Upgradable {\r\n    enum Status {\r\n        Pending,\r\n        Fulfilled,\r\n        Canceled\r\n    }\r\n\r\n    //event data provider is listening for, containing all relevant request parameters\r\n    event Incoming(\r\n        uint256 indexed id,\r\n        address indexed provider,\r\n        address indexed subscriber,\r\n        string query,\r\n        bytes32 endpoint,\r\n        bytes32[] endpointParams,\r\n        bool onchainSubscriber\r\n    );\r\n\r\n    event FulfillQuery(\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        bytes32 indexed endpoint\r\n    );\r\n\r\n    event OffchainResponse(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        bytes32[] response\r\n    );\r\n\r\n    event OffchainResponseInt(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        int256[] response\r\n    );\r\n\r\n    event OffchainResult1(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        string response1\r\n    );\r\n\r\n    event OffchainResult2(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        string response1,\r\n        string response2\r\n    );\r\n\r\n    event OffchainResult3(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        string response1,\r\n        string response2,\r\n        string response3\r\n    );\r\n\r\n    event OffchainResult4(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider,\r\n        string response1,\r\n        string response2,\r\n        string response3,\r\n        string response4\r\n    );\r\n\r\n    event CanceledRequest(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider\r\n    );\r\n\r\n    event RevertCancelation(\r\n        uint256 indexed id,\r\n        address indexed subscriber,\r\n        address indexed provider\r\n    );\r\n\r\n    BondageInterface public bondage;\r\n    address public bondageAddress;\r\n\r\n    DatabaseInterface public db;\r\n\r\n    constructor(address c) public Upgradable(c) {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        address databaseAddress = coordinator.getContract('DATABASE');\r\n        db = DatabaseInterface(databaseAddress);\r\n\r\n        bondageAddress = coordinator.getContract('BONDAGE');\r\n        bondage = BondageInterface(bondageAddress);\r\n    }\r\n\r\n    /// @notice Escrow dot for oracle request\r\n    /// @dev Called by user contract\r\n    function query(\r\n        address provider, // data provider address\r\n        string calldata userQuery, // query string\r\n        bytes32 endpoint, // endpoint specifier ala 'smart_contract'\r\n        bytes32[] calldata endpointParams // endpoint-specific params\r\n    ) external returns (uint256 id) {\r\n        uint256 dots = bondage.getBoundDots(msg.sender, provider, endpoint);\r\n        bool onchainProvider = isContract(provider);\r\n        bool onchainSubscriber = isContract(msg.sender);\r\n\r\n        if (dots >= 1) {\r\n            //enough dots\r\n            bondage.escrowDots(msg.sender, provider, endpoint, 1);\r\n\r\n            id = uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        block.number,\r\n                        block.timestamp,\r\n                        userQuery,\r\n                        msg.sender,\r\n                        provider\r\n                    )\r\n                )\r\n            );\r\n\r\n            createQuery(\r\n                id,\r\n                provider,\r\n                msg.sender,\r\n                endpoint,\r\n                userQuery,\r\n                onchainSubscriber\r\n            );\r\n            if (onchainProvider) {\r\n                OnChainProvider(provider).receiveQuery(\r\n                    id,\r\n                    userQuery,\r\n                    endpoint,\r\n                    endpointParams,\r\n                    onchainSubscriber\r\n                );\r\n            } else {\r\n                emit Incoming(\r\n                    id,\r\n                    provider,\r\n                    msg.sender,\r\n                    userQuery,\r\n                    endpoint,\r\n                    endpointParams,\r\n                    onchainSubscriber\r\n                );\r\n            }\r\n        } else {\r\n            // NOT ENOUGH DOTS\r\n            revert('Subscriber does not have any dots.');\r\n        }\r\n    }\r\n\r\n    /// @notice Transfer dots from Bondage escrow to data provider's Holder object under its own address\r\n    /// @dev Called upon data-provider request fulfillment\r\n    function fulfillQuery(uint256 id) private returns (bool) {\r\n        Status status = Status(getStatus(id));\r\n\r\n        require(status != Status.Fulfilled, 'Error: Status already fulfilled');\r\n\r\n        address subscriber = getSubscriber(id);\r\n        address provider = getProvider(id);\r\n        bytes32 endpoint = getEndpoint(id);\r\n\r\n        if (status == Status.Canceled) {\r\n            uint256 canceled = getCancel(id);\r\n\r\n            // Make sure we've canceled in the past,\r\n            // if it's current block ignore the cancel\r\n            require(block.number == canceled, 'Error: Cancel ignored');\r\n\r\n            // Uncancel the query\r\n            setCanceled(id, false);\r\n\r\n            // Re-escrow the previously returned dots\r\n            bondage.escrowDots(subscriber, provider, endpoint, 1);\r\n\r\n            // Emit the events\r\n            emit RevertCancelation(id, subscriber, provider);\r\n        }\r\n\r\n        setFulfilled(id);\r\n\r\n        bondage.releaseDots(subscriber, provider, endpoint, 1);\r\n\r\n        emit FulfillQuery(subscriber, provider, endpoint);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Cancel a query.\r\n    /// @dev If responded on the same block, ignore the cancel.\r\n    function cancelQuery(uint256 id) external {\r\n        address subscriber = getSubscriber(id);\r\n        address provider = getProvider(id);\r\n        bytes32 endpoint = getEndpoint(id);\r\n\r\n        require(subscriber == msg.sender, 'Error: Wrong subscriber');\r\n        require(\r\n            Status(getStatus(id)) == Status.Pending,\r\n            'Error: Query is not pending'\r\n        );\r\n\r\n        // Cancel the query\r\n        setCanceled(id, true);\r\n\r\n        // Return the dots to the subscriber\r\n        bondage.returnDots(subscriber, provider, endpoint, 1);\r\n\r\n        // Release an event\r\n        emit CanceledRequest(id, getSubscriber(id), getProvider(id));\r\n    }\r\n\r\n    /// @dev Parameter-count specific method called by data provider in response\r\n    function respondBytes32Array(uint256 id, bytes32[] calldata response)\r\n        external\r\n        returns (bool)\r\n    {\r\n        if (getProvider(id) != msg.sender || !fulfillQuery(id)) revert();\r\n        if (getSubscriberOnchain(id)) {\r\n            ClientBytes32Array(getSubscriber(id)).callback(id, response);\r\n        } else {\r\n            emit OffchainResponse(id, getSubscriber(id), msg.sender, response);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Parameter-count specific method called by data provider in response\r\n    function respondIntArray(uint256 id, int256[] calldata response)\r\n        external\r\n        returns (bool)\r\n    {\r\n        if (getProvider(id) != msg.sender || !fulfillQuery(id)) revert();\r\n        if (getSubscriberOnchain(id)) {\r\n            ClientIntArray(getSubscriber(id)).callback(id, response);\r\n        } else {\r\n            emit OffchainResponseInt(\r\n                id,\r\n                getSubscriber(id),\r\n                msg.sender,\r\n                response\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Parameter-count specific method called by data provider in response\r\n    function respond1(uint256 id, string calldata response)\r\n        external\r\n        returns (bool)\r\n    {\r\n        if (getProvider(id) != msg.sender || !fulfillQuery(id)) revert();\r\n\r\n        if (getSubscriberOnchain(id)) {\r\n            Client1(getSubscriber(id)).callback(id, response);\r\n        } else {\r\n            emit OffchainResult1(id, getSubscriber(id), msg.sender, response);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Parameter-count specific method called by data provider in response\r\n    function respond2(\r\n        uint256 id,\r\n        string calldata response1,\r\n        string calldata response2\r\n    ) external returns (bool) {\r\n        if (getProvider(id) != msg.sender || !fulfillQuery(id)) revert();\r\n\r\n        if (getSubscriberOnchain(id)) {\r\n            Client2(getSubscriber(id)).callback(id, response1, response2);\r\n        } else {\r\n            emit OffchainResult2(\r\n                id,\r\n                getSubscriber(id),\r\n                msg.sender,\r\n                response1,\r\n                response2\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Parameter-count specific method called by data provider in response\r\n    function respond3(\r\n        uint256 id,\r\n        string calldata response1,\r\n        string calldata response2,\r\n        string calldata response3\r\n    ) external returns (bool) {\r\n        if (getProvider(id) != msg.sender || !fulfillQuery(id)) revert();\r\n\r\n        if (getSubscriberOnchain(id)) {\r\n            Client3(getSubscriber(id)).callback(\r\n                id,\r\n                response1,\r\n                response2,\r\n                response3\r\n            );\r\n        } else {\r\n            emit OffchainResult3(\r\n                id,\r\n                getSubscriber(id),\r\n                msg.sender,\r\n                response1,\r\n                response2,\r\n                response3\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Parameter-count specific method called by data provider in response\r\n    function respond4(\r\n        uint256 id,\r\n        string calldata response1,\r\n        string calldata response2,\r\n        string calldata response3,\r\n        string calldata response4\r\n    ) external returns (bool) {\r\n        if (getProvider(id) != msg.sender || !fulfillQuery(id)) revert();\r\n\r\n        if (getSubscriberOnchain(id)) {\r\n            Client4(getSubscriber(id)).callback(\r\n                id,\r\n                response1,\r\n                response2,\r\n                response3,\r\n                response4\r\n            );\r\n        } else {\r\n            emit OffchainResult4(\r\n                id,\r\n                getSubscriber(id),\r\n                msg.sender,\r\n                response1,\r\n                response2,\r\n                response3,\r\n                response4\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /*** STORAGE METHODS ***/\r\n\r\n    /// @dev get provider address of request\r\n    /// @param id request id\r\n    function getProvider(uint256 id) public view returns (address) {\r\n        return\r\n            address(\r\n                db.getNumber(\r\n                    keccak256(abi.encodePacked('queries', id, 'provider'))\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @dev get subscriber address of request\r\n    /// @param id request id\r\n    function getSubscriber(uint256 id) public view returns (address) {\r\n        return\r\n            address(\r\n                db.getNumber(\r\n                    keccak256(abi.encodePacked('queries', id, 'subscriber'))\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @dev get endpoint of request\r\n    /// @param id request id\r\n    function getEndpoint(uint256 id) public view returns (bytes32) {\r\n        return\r\n            db.getBytes32(\r\n                keccak256(abi.encodePacked('queries', id, 'endpoint'))\r\n            );\r\n    }\r\n\r\n    /// @dev get status of request\r\n    /// @param id request id\r\n    function getStatus(uint256 id) public view returns (uint256) {\r\n        return\r\n            db.getNumber(keccak256(abi.encodePacked('queries', id, 'status')));\r\n    }\r\n\r\n    /// @dev get the cancelation block of a request\r\n    /// @param id request id\r\n    function getCancel(uint256 id) public view returns (uint256) {\r\n        return\r\n            db.getNumber(\r\n                keccak256(abi.encodePacked('queries', id, 'cancelBlock'))\r\n            );\r\n    }\r\n\r\n    /// @dev get user specified query of request\r\n    /// @param id request id\r\n    function getUserQuery(uint256 id) public view returns (string memory) {\r\n        return\r\n            db.getString(\r\n                keccak256(abi.encodePacked('queries', id, 'userQuery'))\r\n            );\r\n    }\r\n\r\n    /// @dev is subscriber contract or offchain\r\n    /// @param id request id\r\n    function getSubscriberOnchain(uint256 id) public view returns (bool) {\r\n        uint256 res = db.getNumber(\r\n            keccak256(abi.encodePacked('queries', id, 'onchainSubscriber'))\r\n        );\r\n        return res == 1 ? true : false;\r\n    }\r\n\r\n    /**** Set Methods ****/\r\n    function createQuery(\r\n        uint256 id,\r\n        address provider,\r\n        address subscriber,\r\n        bytes32 endpoint,\r\n        string memory userQuery,\r\n        bool onchainSubscriber\r\n    ) private {\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('queries', id, 'provider')),\r\n            uint256(provider)\r\n        );\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('queries', id, 'subscriber')),\r\n            uint256(subscriber)\r\n        );\r\n        db.setBytes32(\r\n            keccak256(abi.encodePacked('queries', id, 'endpoint')),\r\n            endpoint\r\n        );\r\n        db.setString(\r\n            keccak256(abi.encodePacked('queries', id, 'userQuery')),\r\n            userQuery\r\n        );\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('queries', id, 'status')),\r\n            uint256(Status.Pending)\r\n        );\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('queries', id, 'onchainSubscriber')),\r\n            onchainSubscriber ? 1 : 0\r\n        );\r\n    }\r\n\r\n    function setFulfilled(uint256 id) private {\r\n        db.setNumber(\r\n            keccak256(abi.encodePacked('queries', id, 'status')),\r\n            uint256(Status.Fulfilled)\r\n        );\r\n    }\r\n\r\n    function setCanceled(uint256 id, bool canceled) private {\r\n        if (canceled) {\r\n            db.setNumber(\r\n                keccak256(abi.encodePacked('queries', id, 'cancelBlock')),\r\n                block.number\r\n            );\r\n            db.setNumber(\r\n                keccak256(abi.encodePacked('queries', id, 'status')),\r\n                uint256(Status.Canceled)\r\n            );\r\n        } else {\r\n            db.setNumber(\r\n                keccak256(abi.encodePacked('queries', id, 'cancelBlock')),\r\n                0\r\n            );\r\n            db.setNumber(\r\n                keccak256(abi.encodePacked('queries', id, 'status')),\r\n                uint256(Status.Pending)\r\n            );\r\n        }\r\n    }\r\n\r\n    function isContract(address addr) private view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/*\r\n/* For use in example contract, see TestContracts.sol\r\n/*\r\n/* When User Contract calls ZapDispatch.query(),\r\n/* 1 oracle specific dot is escrowed by ZapBondage and Incoming event is ted.\r\n/*\r\n/* When provider's client hears an Incoming event containing provider's address and responds,\r\n/* the provider calls a ZapDispatch.respondX function corresponding to number of response params.\r\n/*\r\n/* Dots are moved from ZapBondage escrow to data-provider's bond Holder struct,\r\n/* with data provider address set as self's address.\r\n/*/\r\n\r\n/*************************************** STORAGE ****************************************\r\n * 'queries', id, 'provider' => {address} address of provider that this query was sent to\r\n * 'queries', id, 'subscriber' => {address} address of subscriber that this query was sent by\r\n * 'queries', id, 'endpoint' => {bytes32} endpoint that this query was sent to\r\n * 'queries', id, 'status' => {Status} current status of this query\r\n * 'queries', id, 'cancelBlock' => {uint256} the block number of the cancellation request (0 if none)\r\n * 'queries', id, 'userQuery' => {uint256} the query that was sent with this queryId\r\n * 'queries', id, 'onchainSubscriber' => {uint256} 1 -> onchainSubscriber, 0 -> offchainSubscriber\r\n ****************************************************************************************/\r\n"
    },
    "contracts/lib/platform/Client.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract Client1 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    function callback(uint256 id, string calldata response1)  external;\r\n}\r\n contract Client2 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    /// @param response2 second provider-specified param\r\n    function callback(uint256 id, string calldata response1, string calldata response2)  external;\r\n}\r\n contract Client3 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    /// @param response2 second provider-specified param\r\n    /// @param response3 third provider-specified param\r\n    function callback(uint256 id, string calldata response1, string calldata response2, string calldata response3)  external;\r\n}\r\n contract Client4 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    /// @param response2 second provider-specified param\r\n    /// @param response3 third provider-specified param\r\n    /// @param response4 fourth provider-specified param\r\n    function callback(uint256 id, string calldata response1, string calldata response2, string calldata response3, string calldata response4)  external;\r\n}\r\n\r\n contract ClientBytes32Array {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response bytes32 array\r\n    function callback(uint256 id, bytes32[] calldata response)  external;\r\n}\r\n\r\n contract ClientIntArray{\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response int array\r\n    function callback(uint256 id, int[] calldata response)  external;\r\n}\r\n"
    },
    "contracts/lib/platform/OnChainProvider.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract OnChainProvider {\r\n    /// @dev function for requesting data from on-chain provider\r\n    /// @param id request id\r\n    /// @param userQuery query string\r\n    /// @param endpoint endpoint specifier ala 'smart_contract'\r\n    /// @param endpointParams endpoint-specific params\r\n    function receiveQuery(uint256 id, string calldata userQuery, bytes32 endpoint, bytes32[] calldata endpointParams, bool onchainSubscriber)  external;\r\n}\r\n"
    },
    "contracts/platform/dispatch/DispatchInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\ninterface DispatchInterface {\r\n    function query(address, string calldata, bytes32, bytes32[] calldata) external returns (uint256);\r\n    function respond1(uint256, string calldata) external returns (bool);\r\n    function respond2(uint256, string calldata, string calldata) external returns (bool);\r\n    function respond3(uint256, string calldata, string calldata, string calldata) external returns (bool);\r\n    function respond4(uint256, string calldata, string calldata, string calldata, string calldata) external returns (bool);\r\n    function respondBytes32Array(uint256, bytes32[] calldata) external returns (bool);\r\n    function respondIntArray(uint256,int[] calldata) external returns (bool);\r\n    function cancelQuery(uint256) external;\r\n    function getProvider(uint256 id) external view returns (address);\r\n    function getSubscriber(uint256 id) external view returns (address);\r\n    function getEndpoint(uint256 id) external view returns (bytes32);\r\n    function getStatus(uint256 id) external view returns (uint256);\r\n    function getCancel(uint256 id) external view returns (uint256);\r\n    function getUserQuery(uint256 id) external view returns (string memory);\r\n    function getSubscriberOnchain(uint256 id) external view returns (bool);\r\n}\r\n"
    },
    "contracts/platform/registry/Registry.sol": {
      "content": "pragma solidity =0.5.16;\r\n// v1.0\r\n\r\nimport \"../../lib/lifecycle/Destructible.sol\";\r\nimport \"../../lib/ownership/Upgradable.sol\";\r\nimport \"../database/DatabaseInterface.sol\";\r\nimport \"./RegistryInterface.sol\";\r\n\r\ncontract Registry is Destructible, RegistryInterface, Upgradable {\r\n\r\n    event NewProvider(\r\n        address indexed provider,\r\n        bytes32 indexed title\r\n    );\r\n\r\n    event NewCurve(\r\n        address indexed provider,\r\n        bytes32 indexed endpoint,\r\n        int[] curve,\r\n        address indexed broker\r\n    );\r\n\r\n    DatabaseInterface public db;\r\n\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        address databaseAddress = coordinator.getContract(\"DATABASE\");\r\n        db = DatabaseInterface(databaseAddress);\r\n    }\r\n\r\n    /// @dev initiates a provider.\r\n    /// If no address->Oracle mapping exists, Oracle object is created\r\n    /// @param publicKey unique id for provider. used for encyrpted key swap for subscription endpoints\r\n    /// @param title name\r\n    function initiateProvider(\r\n        uint256 publicKey,\r\n        bytes32 title\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(!isProviderInitiated(msg.sender), \"Error: Provider is already initiated\");\r\n        createOracle(msg.sender, publicKey, title);\r\n        addOracle(msg.sender);\r\n        emit NewProvider(msg.sender, title);\r\n        return true;\r\n    }\r\n\r\n    /// @dev initiates an endpoint specific provider curve\r\n    /// If oracle[specfifier] is uninitialized, Curve is mapped to endpoint\r\n    /// @param endpoint specifier of endpoint. currently \"smart_contract\" or \"socket_subscription\"\r\n    /// @param curve flattened array of all segments, coefficients across all polynomial terms, [e0,l0,c0,c1,c2,...]\r\n    /// @param broker address for endpoint. if non-zero address, only this address will be able to bond/unbond\r\n    function initiateProviderCurve(\r\n        bytes32 endpoint,\r\n        int256[] memory curve,\r\n        address broker\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not yet initiated\");\r\n        // Can't reset their curve\r\n        require(getCurveUnset(msg.sender, endpoint), \"Error: Curve is already set\");\r\n        // Can't initiate null endpoint\r\n        require(endpoint != bytes32(0), \"Error: Can't initiate null endpoint\");\r\n\r\n        setCurve(msg.sender, endpoint, curve);\r\n        db.pushBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'endpoints')), endpoint);\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', msg.sender, endpoint, 'broker')), stringToBytes32(string(abi.encodePacked(broker))));\r\n\r\n        emit NewCurve(msg.sender, endpoint, curve, broker);\r\n\r\n        return true;\r\n    }\r\n\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n    bytes memory tempEmptyStringTest = bytes(source);\r\n    if (tempEmptyStringTest.length == 0) {\r\n        return 0x0;\r\n    }\r\n\r\n    assembly {\r\n        result := mload(add(source, 32))\r\n    }\r\n}\r\n    // Sets provider data\r\n    function setProviderParameter(bytes32 key, bytes memory value) public {\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not yet initiated\");\r\n\r\n        if (!isProviderParamInitialized(msg.sender, key)) {\r\n            // initialize this provider param\r\n            db.setNumber(keccak256(abi.encodePacked('oracles', msg.sender, 'is_param_set', key)), 1);\r\n            db.pushBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'providerParams')), key);\r\n        }\r\n        db.setBytes(keccak256(abi.encodePacked('oracles', msg.sender, 'providerParams', key)), value);\r\n    }\r\n\r\n    // Gets provider data\r\n    function getProviderParameter(address provider, bytes32 key) public view returns (bytes memory){\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(provider), \"Error: Provider is not yet initiated\");\r\n        require(isProviderParamInitialized(provider, key), \"Error: Provider Parameter is not yet initialized\");\r\n        return db.getBytes(keccak256(abi.encodePacked('oracles', provider, 'providerParams', key)));\r\n    }\r\n\r\n    // Gets keys of all provider params\r\n    function getAllProviderParams(address provider) public view returns (bytes32[] memory){\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(provider), \"Error: Provider is not yet initiated\");\r\n        return db.getBytesArray(keccak256(abi.encodePacked('oracles', provider, 'providerParams')));\r\n    }\r\n\r\n    // Set endpoint specific parameters for a given endpoint\r\n    function setEndpointParams(bytes32 endpoint, bytes32[] memory endpointParams) public {\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not yet initialized\");\r\n        // Can't set endpoint params on an unset provider\r\n        require(!getCurveUnset(msg.sender, endpoint), \"Error: Curve is not yet set\");\r\n\r\n        db.setBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'endpointParams', endpoint)), endpointParams);\r\n    }\r\n\r\n    //Set title for registered provider account\r\n    function setProviderTitle(bytes32 title) public {\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not initiated\");\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', msg.sender, \"title\")), title);\r\n    }\r\n\r\n    //Clear an endpoint with no bonds\r\n    function clearEndpoint(bytes32 endpoint) public {\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not initiated\");\r\n\r\n        uint256 bound = db.getNumber(keccak256(abi.encodePacked('totalBound', msg.sender, endpoint)));\r\n        require(bound == 0, \"Error: Endpoint must have no bonds\");\r\n\r\n        int256[] memory nullArray = new int256[](0);\r\n        bytes32[] memory endpoints =  db.getBytesArray(keccak256(abi.encodePacked(\"oracles\", msg.sender, \"endpoints\")));\r\n        for(uint256 i = 0; i < endpoints.length; i++) {\r\n            if(endpoints[i] == endpoint) {\r\n               db.setBytesArrayIndex(keccak256(abi.encodePacked(\"oracles\", msg.sender, \"endpoints\")), i, bytes32(0));\r\n               break;\r\n            }\r\n        }\r\n        db.pushBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'endpoints')), bytes32(0));\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', msg.sender, endpoint, 'broker')), bytes32(0));\r\n        db.setIntArray(keccak256(abi.encodePacked('oracles', msg.sender, 'curves', endpoint)), nullArray);\r\n    }\r\n\r\n    /// @return public key\r\n    function getProviderPublicKey(address provider) public view returns (uint256) {\r\n        return getPublicKey(provider);\r\n    }\r\n\r\n    /// @return oracle name\r\n    function getProviderTitle(address provider) public view returns (bytes32) {\r\n        return getTitle(provider);\r\n    }\r\n\r\n\r\n    /// @dev get curve paramaters from oracle\r\n    function getProviderCurve(\r\n        address provider,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (int[] memory)\r\n    {\r\n        require(!getCurveUnset(provider, endpoint), \"Error: Curve is not yet set\");\r\n        return db.getIntArray(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint)));\r\n    }\r\n\r\n    function getProviderCurveLength(address provider, bytes32 endpoint) public view returns (uint256){\r\n        require(!getCurveUnset(provider, endpoint), \"Error: Curve is not yet set\");\r\n        return db.getIntArray(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint))).length;\r\n    }\r\n\r\n    /// @dev is provider initiated\r\n    /// @param oracleAddress the provider address\r\n    /// @return Whether or not the provider has initiated in the Registry.\r\n    function isProviderInitiated(address oracleAddress) public view returns (bool) {\r\n        return getProviderTitle(oracleAddress) != 0;\r\n    }\r\n\r\n    /*** STORAGE FUNCTIONS ***/\r\n    /// @dev get public key of provider\r\n    function getPublicKey(address provider) public view returns (uint256) {\r\n        return db.getNumber(keccak256(abi.encodePacked(\"oracles\", provider, \"publicKey\")));\r\n    }\r\n\r\n    /// @dev get title of provider\r\n    function getTitle(address provider) public view returns (bytes32) {\r\n        return db.getBytes32(keccak256(abi.encodePacked(\"oracles\", provider, \"title\")));\r\n    }\r\n\r\n    /// @dev get the endpoints of a provider\r\n    function getProviderEndpoints(address provider) public view returns (bytes32[] memory) {\r\n        return db.getBytesArray(keccak256(abi.encodePacked(\"oracles\", provider, \"endpoints\")));\r\n    }\r\n\r\n    /// @dev get all endpoint params\r\n    function getEndpointParams(address provider, bytes32 endpoint) public view returns (bytes32[] memory) {\r\n        return db.getBytesArray(keccak256(abi.encodePacked('oracles', provider, 'endpointParams', endpoint)));\r\n    }\r\n\r\n    /// @dev get broker address for endpoint\r\n    function getEndpointBroker(address oracleAddress, bytes32 endpoint) public view returns (address) {\r\n        return address(uint160(uint256(db.getBytes32(keccak256(abi.encodePacked('oracles', oracleAddress, endpoint, 'broker'))))));\r\n    }\r\n\r\n    function getCurveUnset(address provider, bytes32 endpoint) public view returns (bool) {\r\n        return db.getIntArrayLength(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint))) == 0;\r\n    }\r\n\r\n    /// @dev get provider address by index\r\n    function getOracleAddress(uint256 index) public view returns (address) {\r\n        return db.getAddressArrayIndex(keccak256(abi.encodePacked('oracleIndex')), index);\r\n    }\r\n\r\n    /// @dev get all oracle addresses\r\n    function getAllOracles() external view returns (address[] memory) {\r\n        return db.getAddressArray(keccak256(abi.encodePacked('oracleIndex')));\r\n    }\r\n\r\n    ///  @dev add new provider to mapping\r\n    function createOracle(address provider, uint256 publicKey, bytes32 title) private {\r\n        db.setNumber(keccak256(abi.encodePacked('oracles', provider, \"publicKey\")), uint256(publicKey));\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', provider, \"title\")), title);\r\n    }\r\n\r\n    /// @dev add new provider address to oracles array\r\n    function addOracle(address provider) private {\r\n        db.pushAddressArray(keccak256(abi.encodePacked('oracleIndex')), provider);\r\n    }\r\n\r\n    /// @dev initialize new curve for provider\r\n    /// @param provider address of provider\r\n    /// @param endpoint endpoint specifier\r\n    /// @param curve flattened array of all segments, coefficients across all polynomial terms, [l0,c0,c1,c2,..., ck, e0, ...]\r\n    function setCurve(\r\n        address provider,\r\n        bytes32 endpoint,\r\n        int[] memory curve\r\n    )\r\n        private\r\n    {\r\n        uint prevEnd = 1;\r\n        uint index = 0;\r\n\r\n        // Validate the curve\r\n        while (index < curve.length) {\r\n            // Validate the length of the piece\r\n            int len = curve[index];\r\n            require(len > 0, \"Error: Invalid Curve\");\r\n\r\n            // Validate the end index of the piece\r\n            uint endIndex = index + uint(len) + 1;\r\n            require(endIndex < curve.length, \"Error: Invalid Curve\");\r\n\r\n            // Validate that the end is continuous\r\n            int end = curve[endIndex];\r\n            require(uint(end) > prevEnd, \"Error: Invalid Curve\");\r\n\r\n            prevEnd = uint(end);\r\n            index += uint(len) + 2;\r\n        }\r\n\r\n        db.setIntArray(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint)), curve);\r\n    }\r\n\r\n    // Determines whether this parameter has been initialized\r\n    function isProviderParamInitialized(address provider, bytes32 key) private view returns (bool){\r\n        uint256 val = db.getNumber(keccak256(abi.encodePacked('oracles', provider, 'is_param_set', key)));\r\n        return (val == 1) ? true : false;\r\n    }\r\n\r\n    /*************************************** STORAGE ****************************************\r\n    * 'oracles', provider, 'endpoints' => {bytes32[]} array of endpoints for this oracle\r\n    * 'oracles', provider, 'endpointParams', endpoint => {bytes32[]} array of params for this endpoint\r\n    * 'oracles', provider, 'curves', endpoint => {uint[]} curve array for this endpoint\r\n    * 'oracles', provider, 'broker', endpoint => {bytes32} broker address for this endpoint\r\n    * 'oracles', provider, 'is_param_set', key => {uint} Is this provider parameter set (0/1)\r\n    * 'oracles', provider, \"publicKey\" => {uint} public key for this oracle\r\n    * 'oracles', provider, \"title\" => {bytes32} title of this oracle\r\n    ****************************************************************************************/\r\n}\r\n"
    },
    "contracts/platform/registry/RegistryInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract RegistryInterface {\r\n    function initiateProvider(uint256, bytes32) public  returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[] memory, address) public  returns (bool);\r\n    function setEndpointParams(bytes32, bytes32[] memory) public ;\r\n    function getEndpointParams(address, bytes32) public  view returns (bytes32[] memory );\r\n    function getProviderPublicKey(address) public  view returns (uint256);\r\n    function getProviderTitle(address) public  view returns (bytes32);\r\n    function setProviderParameter(bytes32, bytes memory) public ;\r\n    function setProviderTitle(bytes32) public ;\r\n    function clearEndpoint(bytes32) public ;\r\n    function getProviderParameter(address, bytes32) public  view returns (bytes memory);\r\n    function getAllProviderParams(address) public  view returns (bytes32[] memory);\r\n    function getProviderCurveLength(address, bytes32) public  view returns (uint256);\r\n    function getProviderCurve(address, bytes32) public  view returns (int[] memory);\r\n    function isProviderInitiated(address) public  view returns (bool);\r\n    function getAllOracles() external  view returns (address[] memory);\r\n    function getProviderEndpoints(address) public  view returns (bytes32[] memory);\r\n    function getEndpointBroker(address, bytes32) public  view returns (address);\r\n}\r\n"
    },
    "contracts/platform/bondage/currentCost/CurrentCost.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"../../../lib/lifecycle/Destructible.sol\";\r\nimport \"../../../lib/ownership/Upgradable.sol\";\r\nimport \"../../../lib/platform/PiecewiseLogic.sol\";\r\nimport \"../../registry/RegistryInterface.sol\";\r\nimport \"./CurrentCostInterface.sol\";\r\n\r\n\r\ncontract CurrentCost is Destructible, CurrentCostInterface, Upgradable {\r\n\r\n    RegistryInterface registry;\r\n\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies()  internal {\r\n        registry = RegistryInterface(coordinator.getContract(\"REGISTRY\"));\r\n    }\r\n\r\n    /// @dev calculates current cost of dot\r\n    /// @param oracleAddress oracle address\r\n    /// @param endpoint oracle endpoint\r\n    /// @param start nth dot to calculate price of\r\n    /// @return cost of next dot\r\n    function _currentCostOfDot(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 start\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 cost)\r\n    {\r\n        return _costOfNDots(oracleAddress, endpoint, start, 0);\r\n    }\r\n\r\n    /// @dev calculates cost of n dots\r\n    /// @param oracleAddress oracle address\r\n    /// @param endpoint oracle endpoint\r\n    /// @param start nth dot to start calculating price at\r\n    /// @param nDots to bond\r\n    /// @return cost of next dot\r\n    function _costOfNDots(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 start,\r\n        uint256 nDots\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 cost)\r\n    {\r\n        uint256 length = registry.getProviderCurveLength(oracleAddress,endpoint);\r\n        int[] memory curve = new int[](length);\r\n        curve = registry.getProviderCurve(oracleAddress, endpoint);\r\n\r\n        int res = PiecewiseLogic.evaluateFunction(curve, start, nDots);\r\n        require(res >= 0, \"Error: Cost of dots cannot be negative\");\r\n        return uint256(res);\r\n    }\r\n\r\n   function _dotLimit(\r\n        address oracleAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 length = registry.getProviderCurveLength(oracleAddress,endpoint);\r\n        int[] memory curve = new int[](length);\r\n        curve = registry.getProviderCurve(oracleAddress, endpoint);\r\n\r\n        return uint(curve[length-1]);\r\n    }\r\n}\r\n"
    },
    "contracts/lib/platform/PiecewiseLogic.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nlibrary PiecewiseLogic {\r\n    function sumOfPowers(uint n, uint i) internal pure returns (uint) {\r\n        require(i <= 6 && i >= 0, \"Error: Invalid Piecewise Logic\");\r\n\r\n        if (i == 0) return n;\r\n        if (i == 1) return (n * (n + 1)) / 2;\r\n        if (i == 2) return (n * (n + 1) * (2 * n + 1)) / 6;\r\n        if (i == 3) return ((n * (n + 1)) / 2) ** 2;\r\n        if (i == 4) return (n * (n + 1) * (2 * n + 1) * (3 * n * n + 3 * n - 1)) / 30;\r\n        if (i == 5) return (n * (n + 1)) ** 2 * (2 * n ** 2 + 2 * n - 1);\r\n        if (i == 6) return (n * (n + 1) * (2 * n + 1) * (3 * n ** 4 + 6 * n ** 3 - 3 * n + 1)) / 42;\r\n\r\n        // impossible\r\n        return 0;\r\n    }\r\n\r\n    function evaluateFunction(int[] memory curve, uint a, uint b) internal pure returns (int) {\r\n        uint i = 0;\r\n        int sum = 0;\r\n\r\n        // Require to be within the dot limit\r\n        require(a + b <= uint(curve[curve.length - 1]), \"Error: Function not in dot limit\");\r\n\r\n        // Loop invariant: i should always point to the start of a piecewise piece (the length)\r\n        while (i < curve.length) {\r\n            uint l = uint(curve[i]);\r\n            uint end = uint(curve[i + l + 1]);\r\n\r\n            // Index of the next piece's end\r\n            uint nextIndex = i + l + 2;\r\n\r\n            if (a > end) { // move on to the next piece\r\n                i = nextIndex;\r\n                continue;\r\n            }\r\n\r\n            sum += evaluatePiece(curve, i, a, (a + b > end) ? end - a : b);\r\n\r\n            if (a + b <= end) {\r\n                // Entire calculation is within this piece\r\n                return sum;\r\n            }\r\n            else {\r\n                b -= end - a + 1; // Remove the dots we've already bound from b\r\n                a = end;          // Move a up to the end\r\n                i = nextIndex;    // Move index up\r\n            }\r\n        }\r\n    }\r\n\r\n    function evaluatePiece(int[] memory curve, uint index, uint a, uint b) internal pure returns (int) {\r\n        int sum = 0;\r\n        uint len = uint(curve[index]);\r\n        uint base = index + 1;\r\n        uint end = base + len; // index of last term\r\n\r\n        // iterate between index+1 and the end of this piece\r\n        for (uint i = base; i < end; i++) {\r\n            sum += curve[i] * int(sumOfPowers(a + b, i - base) - sumOfPowers(a - 1, i - base));\r\n        }\r\n\r\n        require(sum >= 0, \"Error: Cost must be greater than zero\");\r\n        return sum;\r\n    }\r\n}\r\n"
    },
    "contracts/lib/platform/TokenDotFactory.sol": {
      "content": "import \"../token/TokenFactoryInterface.sol\";\nimport \"../token/FactoryTokenInterface.sol\";\nimport \"../ownership/ZapCoordinatorInterface.sol\";\nimport \"../../platform/bondage/BondageInterface.sol\";\nimport \"../../platform/bondage/currentCost/CurrentCostInterface.sol\";\nimport \"../../platform/registry/RegistryInterface.sol\";\nimport \"../../platform/bondage/currentCost/CurrentCostInterface.sol\";\n\ncontract DotFactoryFactory{\n    address[] public deployedFactories;\n    uint[] public pubkeys;\n    bytes32[] public providerTitles;\n    \n    address public coordinator;\n    address public factory;\n    event newDotFactory(address dotfactory,uint PubKey,bytes32 Title );\n\n    constructor(address _coordinator,address _factory)  public {\n        coordinator=_coordinator;\n        factory=_factory;\n    }\n    function deployFactory(uint256 providerPubKey,bytes32 providerTitle ) public returns(address){\n        TokenDotFactory TDF=  new TokenDotFactory(coordinator,factory,providerPubKey,providerTitle);\n        TDF.transferOwnership(msg.sender);\n        deployedFactories.push(address(TDF));\n        pubkeys.push(providerPubKey);\n        providerTitles.push(providerTitle);\n        emit newDotFactory(address(TDF),providerPubKey,providerTitle);\n        return address(TDF);\n    }\n    function getFactories() public view returns(address[] memory,uint[] memory,bytes32[] memory){\n        return(deployedFactories, pubkeys,providerTitles);\n    }\n}\n\ncontract TokenDotFactory is Ownable {\n\n    CurrentCostInterface currentCost;\n    FactoryTokenInterface public reserveToken;\n    ZapCoordinatorInterface public coord;\n    TokenFactoryInterface public tokenFactory;\n    BondageInterface bondage;\n\n    mapping(bytes32 => address) public curves; // map of endpoint specifier to token-backed dotaddress\n    bytes32[] public curves_list; // array of endpoint specifiers\n    event DotTokenCreated(address tokenAddress);\n\n    constructor(\n        address coordinator, \n        address factory,\n        uint256 providerPubKey,\n        bytes32 providerTitle \n        \n    )  public{\n        coord = ZapCoordinatorInterface(coordinator); \n        reserveToken = FactoryTokenInterface(coord.getContract(\"ZAP_TOKEN\"));\n        //always allow bondage to transfer from wallet\n        reserveToken.approve(coord.getContract(\"BONDAGE\"), ~uint256(0));\n        tokenFactory = TokenFactoryInterface(factory);\n\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \n        registry.initiateProvider(providerPubKey, providerTitle);\n    }\n\n    function initializeCurve(\n        bytes32 specifier, \n        bytes32 symbol, \n        int256[] memory curve\n    ) public  onlyOwner returns(address) {\n        \n        require(curves[specifier] == address(0), \"Curve specifier already exists\");\n        \n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \n        require(registry.isProviderInitiated(address(this)), \"Provider not intiialized\");\n\n        registry.initiateProviderCurve(specifier, curve, address(this));\n        curves[specifier] = newToken(bytes32ToString(specifier), bytes32ToString(symbol));\n        curves_list.push(specifier);\n        \n        registry.setProviderParameter(specifier, toBytes(curves[specifier]));\n        \n        emit DotTokenCreated(curves[specifier]);\n        return curves[specifier];\n    }\n\n\n    event Bonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); \n\n    //whether this contract holds tokens or coming from msg.sender,etc\n    function bond(bytes32 specifier, uint numDots) public  {\n\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\n        uint256 issued = bondage.getDotsIssued(address(this), specifier);\n\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\n        uint256 numReserve = cost._costOfNDots(address(this), specifier, issued + 1, numDots - 1);\n\n        require(\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\n            \"insufficient accepted token numDots approved for transfer\"\n        );\n\n        reserveToken.approve(address(bondage), numReserve);\n        bondage.bond(address(this), specifier, numDots);\n        FactoryTokenInterface(curves[specifier]).mint(msg.sender, numDots);\n        emit Bonded(specifier, numDots, msg.sender);\n\n    }\n\n    event Unbonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); \n\n    //whether this contract holds tokens or coming from msg.sender,etc\n    function unbond(bytes32 specifier, uint numDots) public {\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\n        uint issued = bondage.getDotsIssued(address(this), specifier);\n\n        currentCost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\n        uint reserveCost = currentCost._costOfNDots(address(this), specifier, issued + 1 - numDots, numDots - 1);\n\n        //unbond dots\n        bondage.unbond(address(this), specifier, numDots);\n        //burn dot backed token\n        FactoryTokenInterface curveToken = FactoryTokenInterface(curves[specifier]);\n        curveToken.burnFrom(msg.sender, numDots);\n\n        require(reserveToken.transfer(msg.sender, reserveCost), \"Error: Transfer failed\");\n        emit Unbonded(specifier, numDots, msg.sender);\n\n    }\n\n    function newToken(\n        string  memory name,\n        string memory symbol\n    ) \n        public\n        onlyOwner\n        returns (address tokenAddress) \n    {\n        FactoryTokenInterface token = tokenFactory.create(name, symbol);\n        tokenAddress = address(token);\n        return tokenAddress;\n    }\n\n    function getTokenAddress(bytes32 endpoint) public view returns(address) {\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\n       // console.log(registry.getProviderParameter(address(this), endpoint));\n        return toAddress(registry.getProviderParameter(address(this), endpoint),0);\n    }\n\n    function getEndpoints() public view returns(bytes32[] memory ){\n      return curves_list;\n    }\n\n    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\n    function toBytes(address x) public pure returns (bytes memory b) {\n        b = new bytes(20);\n        for (uint i = 0; i < 20; i++)\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n    }\n\n    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\n    function bytes32ToString(bytes32 x) public pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n\n        bytesString = abi.encodePacked(x);\n\n        return string(bytesString);\n    }\n\n    \n    function toAddress(bytes memory _bytes, uint256 _start) internal view returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        //console.log(_bytes.length);\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n}\n\n"
    },
    "contracts/lib/token/TokenFactoryInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./FactoryTokenInterface.sol\";\r\n\r\n contract TokenFactoryInterface {\r\n    function create(string memory _name, string memory _symbol)  public returns (FactoryTokenInterface);\r\n}\r\n"
    },
    "contracts/lib/token/FactoryTokenInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"../ownership/Ownable.sol\";\r\n\r\n contract FactoryTokenInterface is Ownable {\r\n    function balanceOf(address _owner) public  view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public  returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool);\r\n    function approve(address _spender, uint256 _value) public  returns (bool);\r\n    function allowance(address _owner, address _spender) public  view returns (uint256);\r\n    function mint(address _to, uint256 _amount) public  returns (bool);\r\n    function burnFrom(address _from, uint256 _value)  public;\r\n}\r\n"
    },
    "contracts/lib/platform/SampleContest.sol": {
      "content": "import \"../token/TokenFactoryInterface.sol\";\r\nimport \"../token/FactoryTokenInterface.sol\";\r\nimport \"../ownership/ZapCoordinatorInterface.sol\";\r\nimport \"../../platform/bondage/BondageInterface.sol\";\r\nimport \"../../platform/bondage/currentCost/CurrentCostInterface.sol\";\r\nimport \"../../platform/registry/RegistryInterface.sol\";\r\nimport \"../../platform/bondage/currentCost/CurrentCostInterface.sol\";\r\npragma solidity =0.5.16;\r\n\r\n/*\r\nContest where users can bond to contestant curves which mint tokens( unbondabe*),\r\nwinner decided by oracle\r\ncontract unbonds from loser curves\r\nholders of winning token allowed to take share of reserve token(zap) which was unbonded from loser curves\r\nStarting Contest:\r\n    deploys with contest uninitialized: status = Uninitialized\r\n    anyone can initialize new token:backed curve\r\n    owner initializes contest with oracle: status = Initialized\r\nEnding Contest:\r\n    owner calls close: status = ReadyToSettle\r\n    oracle calls judge to set winning curve: status = Judged\r\n    anyone calls settle, contest unbonds from losing curves: status = Settled\r\n    holders of winnning token call redeem to retrieve their share of reserve token\r\n    based on their holding of winning token\r\n    *holders of winning token can optionally unbond\r\n*/\r\n\r\ncontract SampleContest is Ownable {\r\n\r\n    CurrentCostInterface currentCost;\r\n    FactoryTokenInterface public reserveToken;\r\n    ZapCoordinatorInterface public coord;\r\n    TokenFactoryInterface public tokenFactory;\r\n    BondageInterface bondage;\r\n\r\n    enum ContestStatus {\r\n        Uninitialized,    //\r\n        Initialized,      // ready for buys\r\n        // ReadyToSettle,    // ready for judgement\r\n        Judged,           // winner determined\r\n        Settled,           // value of winning tokens determined\r\n        Canceled          // oracle did not respond in time\r\n    }\r\n\r\n    address public oracle;    // address of oracle who will choose the winner\r\n    uint256 public ttl;    // time allowed before, close and judge. if time expired, allow unbond from all curves\r\n    // uint256 public expired = 2**256 -1;    // time allowed before, close and judge. if time expired, allow unbond from all curves\r\n    bytes32 public winner;    // curve identifier of the winner\r\n    uint256 public winValue;  // final value of the winning token\r\n    ContestStatus public status; //state of contest\r\n\r\n    mapping(bytes32 => address) public curves; // map of endpoint specifier to token-backed dotaddress\r\n    bytes32[] public curves_list; // array of endpoint specifiers\r\n\r\n    mapping(address => uint8) public redeemed; // map of address redemption state\r\n    address[] public redeemed_list;\r\n\r\n    event DotTokenCreated(address tokenAddress);\r\n    event Bonded(bytes32 indexed endpoint, uint256 indexed numDots, address indexed sender);\r\n    event Unbonded(bytes32 indexed endpoint,uint256 indexed amount, address indexed sender);\r\n\r\n    event Initialized(address indexed oracle);\r\n    event Closed();\r\n    event Judged(bytes32 winner);\r\n    event Settled(uint256 winValue, uint256 winTokens);\r\n    event Reset();\r\n\r\n    constructor(\r\n        address coordinator,\r\n        address factory,\r\n        uint256 providerPubKey,\r\n        bytes32 providerTitle\r\n    ) public {\r\n        coord = ZapCoordinatorInterface(coordinator);\r\n        reserveToken = FactoryTokenInterface(coord.getContract(\"ZAP_TOKEN\"));\r\n        //always allow bondage to transfer from wallet\r\n        reserveToken.approve(coord.getContract(\"BONDAGE\"), ~uint256(0));\r\n        tokenFactory = TokenFactoryInterface(factory);\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n        registry.initiateProvider(providerPubKey, providerTitle);\r\n        status = ContestStatus.Uninitialized;\r\n    }\r\n\r\n// contest lifecycle\r\n\r\n    function initializeContest(\r\n        address oracleAddress,\r\n        uint256 _ttl\r\n    ) onlyOwner public {\r\n        require( status == ContestStatus.Uninitialized, \"Contest already initialized\");\r\n        oracle = oracleAddress;\r\n        ttl = _ttl + block.number;\r\n        status = ContestStatus.Initialized;\r\n        emit Initialized(oracle);\r\n    }\r\n\r\n    function judge(bytes32 endpoint) public {\r\n        require( status == ContestStatus.Initialized, \"Contest not initialized\" );\r\n        require( msg.sender == oracle, \"Only designated Oracle can judge\");\r\n        require(block.number < ttl, \"Contest expired, refund in process\");\r\n        winner = endpoint;\r\n        status = ContestStatus.Judged;\r\n        emit Judged(winner);\r\n    }\r\n\r\n    function settle() public {\r\n        require( status == ContestStatus.Judged, \"winner not determined\");\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        // how many winning dots\r\n        uint256 numWin =  bondage.getDotsIssued(address(this), winner);\r\n        // redeemable value of each dot token\r\n        uint256 dots;\r\n        for( uint256 i = 0; i < curves_list.length; i++) {\r\n          if(curves_list[i]!=winner){\r\n            dots =  bondage.getDotsIssued(address(this), curves_list[i]);\r\n            if( dots > 0) {\r\n                bondage.unbond(address(this), curves_list[i], dots);\r\n            }\r\n          }\r\n        }\r\n        winValue = reserveToken.balanceOf(address(this)) / numWin;\r\n\r\n        status = ContestStatus.Settled;\r\n        emit Settled(winValue, numWin);\r\n    }\r\n\r\n\r\n    //TODO ensure all has been redeemed or enough time has elasped\r\n    function reset() public {\r\n        require(msg.sender == oracle);\r\n        require(status == ContestStatus.Settled || status == ContestStatus.Canceled, \"contest not settled\");\r\n        if( status == ContestStatus.Canceled ) {\r\n            require(reserveToken.balanceOf(address(this)) == 0, \"funds remain\");\r\n        }\r\n\r\n        delete redeemed_list;\r\n        delete curves_list;\r\n        status = ContestStatus.Initialized;\r\n        emit Reset();\r\n    }\r\n\r\n/// TokenDotFactory methods\r\n\r\n    function initializeCurve(\r\n        bytes32 endpoint,\r\n        bytes32 symbol,\r\n        int256[] memory curve\r\n    ) public returns(address) {\r\n        // require(status==ContestStatus.Initialized,\"Contest is not initalized\")\r\n        require(curves[endpoint] == address(0), \"Curve endpoint already exists or used in the past. Please choose a new endpoint\");\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n        registry.initiateProviderCurve(endpoint, curve, address(this));\r\n\r\n        curves[endpoint] = newToken(bytes32ToString(endpoint), bytes32ToString(symbol));\r\n        curves_list.push(endpoint);\r\n        registry.setProviderParameter(endpoint, toBytes(curves[endpoint]));\r\n\r\n        emit DotTokenCreated(curves[endpoint]);\r\n        return curves[endpoint];\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function bond(bytes32 endpoint, uint numDots) public  {\r\n        require( status == ContestStatus.Initialized, \" contest is not initiated\");\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 issued = bondage.getDotsIssued(address(this), endpoint);\r\n\r\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint256 numReserve = cost._costOfNDots(address(this), endpoint, issued + 1, numDots - 1);\r\n\r\n        require(\r\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\r\n            \"insufficient accepted token numDots approved for transfer\"\r\n        );\r\n\r\n        reserveToken.approve(address(bondage), numReserve);\r\n        bondage.bond(address(this), endpoint, numDots);\r\n        FactoryTokenInterface(curves[endpoint]).mint(msg.sender, numDots);\r\n        emit Bonded(endpoint, numDots, msg.sender);\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function unbond(bytes32 endpoint, uint numDots) public returns(uint256) {\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint issued = bondage.getDotsIssued(address(this), endpoint);\r\n\r\n        //unbond dots\r\n        bondage.unbond(address(this), winner, numDots);\r\n\r\n        currentCost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        //get reserve value to send\r\n        uint reserveCost = currentCost._costOfNDots(address(this), endpoint, issued + 1 - numDots, numDots - 1);\r\n\r\n        FactoryTokenInterface curveToken = FactoryTokenInterface(curves[endpoint]);\r\n\r\n        if( status == ContestStatus.Initialized || status == ContestStatus.Canceled) {\r\n            //oracle has taken too long to judge winner so unbonds will be allowed for all\r\n            require(block.number > ttl, \"oracle query not expired.\");\r\n            // require(status == ContestStatus.Settled, \"contest not settled\");\r\n            status = ContestStatus.Canceled;\r\n\r\n            //unbond dots\r\n            //TODO get bound dot then unbond the correct amount ? or unbond all in 1 call\r\n            // bondage.unbond(address(this), endpoint, numDots);\r\n\r\n            //burn dot backed token\r\n            //FIXME only burn the bound tokens ?\r\n            curveToken.burnFrom(msg.sender, numDots);\r\n\r\n            require(reserveToken.transfer(msg.sender, reserveCost), \"transfer failed\");\r\n            emit Unbonded(endpoint, reserveCost, msg.sender);\r\n            return reserveCost;\r\n        }\r\n\r\n        else {\r\n\r\n            require( status == ContestStatus.Settled, \" contest not settled\");\r\n            require(redeemed[msg.sender] == 0, \"already redeeemed\");\r\n            require(winner==endpoint, \"only winners can unbond for rewards\");\r\n\r\n            //reward user's winning tokens unbond value + share of losing curves reserve token proportional to winning token holdings\r\n            uint reward = ( winValue * FactoryTokenInterface(getTokenAddress(winner)).balanceOf(msg.sender) ) + reserveCost;\r\n\r\n            //burn user's unbonded tokens\r\n            // curveToken.approve(address(this),numDots);\r\n            curveToken.burnFrom(msg.sender, numDots);\r\n\r\n            reserveToken.transfer(msg.sender, reward);\r\n            redeemed[msg.sender] = 1;\r\n\r\n            // emit Unbonded(winner, reward, msg.sender);\r\n            return reward;\r\n        }\r\n    }\r\n\r\n    function newToken(\r\n        string memory name,\r\n        string memory symbol\r\n    )\r\n        internal\r\n        returns (address tokenAddress)\r\n    {\r\n        FactoryTokenInterface token = tokenFactory.create(name, symbol);\r\n        tokenAddress = address(token);\r\n        return tokenAddress;\r\n    }\r\n\r\n    function getTokenAddress(bytes32 endpoint) public view returns(address) {\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n        return bytesToAddr(registry.getProviderParameter(address(this), endpoint));\r\n    }\r\n\r\n    function getEndpoints() public view returns(bytes32[] memory ){\r\n      return curves_list;\r\n    }\r\n\r\n    function getStatus() public view returns(uint256){\r\n      return uint(status);\r\n    }\r\n\r\n    function isEndpointValid(bytes32 _endpoint) public view returns(bool){\r\n      for(uint256 i=0; i<curves_list.length;i++){\r\n        if(_endpoint == curves_list[i]){\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\r\n    function toBytes(address x) public pure returns (bytes memory b) {\r\n        b = new bytes(20);\r\n        for (uint i = 0; i < 20; i++)\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\r\n    function bytes32ToString(bytes32 x) public pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        bytesString = abi.encodePacked(x);\r\n        return string(bytesString);\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity\r\n    function bytesToAddr (bytes memory b) public pure returns (address) {\r\n        uint result = 0;\r\n        for (uint i = b.length-1; i+1 > 0; i--) {\r\n            uint c = uint(uint8(b[i]));\r\n            uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n            result += to_inc;\r\n        }\r\n        return address(result);\r\n    }\r\n}\r\n"
    },
    "contracts/lib/token/Token.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./FactoryTokenInterface.sol\";\r\n\r\n// File: contracts/lib/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/Token.sol\r\n\r\ncontract FactoryToken is FactoryTokenInterface {\r\n    using SafeMath for uint256;\r\n\r\n    string public _name;\r\n    string public _symbol;\r\n    uint8 public _decimals = 3;\r\n    uint256 _totalSupply;\r\n\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n    mapping(address => uint256) balances;\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n    event Transfer(address _from, address _to, uint256 _amount);\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n    event Approval(address _from, address _spender, uint256 _value);\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    modifier hasMintPermission() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n    }\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function ownableBurn(uint256 _value) external onlyOwner returns (bool) {\r\n        burn(_value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _value uint256 The amount of token to be burned\r\n    */\r\n    function burnFrom(address _from, uint256 _value) public {\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n        // this function needs to emit an event with the updated approval.\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        _burn(_from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        require(_value <= balances[_who]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        emit Burn(_who, _value);\r\n        emit Transfer(_who, address(0), _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n    hasMintPermission\r\n    canMint\r\n    public\r\n    returns (bool)\r\n    {\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() onlyOwner canMint public returns (bool) {\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom (\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public  returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint _addedValue\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (\r\n        allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint _subtractedValue\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n     function decimals() external view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the token name.\r\n  */\r\n  function name() external view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n    function allocate(address to, uint amount) public{\r\n\r\n        mint(to,amount);\r\n\r\n    }\r\n}\r\n"
    },
    "contracts/lib/token/TokenFactory.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n\r\nimport \"./Token.sol\";\r\nimport \"./TokenFactoryInterface.sol\";\r\n contract TokenFactory is TokenFactoryInterface {\r\n    address[] public generatedTokens;\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    function create(string memory _name, string memory _symbol) public returns (FactoryTokenInterface) {\r\n        FactoryToken token = new FactoryToken(_name, _symbol);\r\n        generatedTokens.push(address(token));\r\n        token.transferOwnership(msg.sender);\r\n        return token;\r\n    }\r\n    function getAllTokens() public returns(address[] memory){\r\n        return generatedTokens;\r\n    }\r\n}\r\n"
    },
    "contracts/platform/database/Database.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./DatabaseInterface.sol\";\r\nimport \"../../lib/ownership/Ownable.sol\";\r\n\r\ncontract Database is Ownable, DatabaseInterface {\r\n    event StorageModified(address indexed contractAddress, bool allowed);\r\n\r\n    mapping (bytes32 => bytes32) data_bytes32;\r\n    mapping (bytes32 => bytes) data_bytes;\r\n    mapping (bytes32 => bytes32[]) data_bytesArray;\r\n    mapping (bytes32 => int[]) data_intArray;\r\n    mapping (bytes32 => address[]) data_addressArray;\r\n    mapping (address => bool) allowed;\r\n\r\n    modifier storageOnly {\r\n        require(allowed[msg.sender], \"Error: Access not allowed to storage\");\r\n        _;\r\n    }\r\n\r\n    function setStorageContract(address _storageContract, bool _allowed) public onlyOwner {\r\n        require(_storageContract != address(0), \"Error: Address zero is invalid storage contract\");\r\n        allowed[_storageContract] = _allowed;\r\n        emit StorageModified(_storageContract, _allowed);\r\n    }\r\n\r\n    /*** Bytes32 ***/\r\n    function getBytes32(bytes32 key) external view returns(bytes32) {\r\n        return data_bytes32[key];\r\n    }\r\n\r\n    function setBytes32(bytes32 key, bytes32 value) external storageOnly  {\r\n        data_bytes32[key] = value;\r\n    }\r\n\r\n    /*** Number **/\r\n    function getNumber(bytes32 key) external view returns(uint256) {\r\n        return uint256(data_bytes32[key]);\r\n    }\r\n\r\n    function setNumber(bytes32 key, uint256 value) external storageOnly {\r\n        data_bytes32[key] = bytes32(value);\r\n    }\r\n\r\n    /*** Bytes ***/\r\n    function getBytes(bytes32 key) external view returns(bytes memory) {\r\n        return data_bytes[key];\r\n    }\r\n\r\n    function setBytes(bytes32 key, bytes calldata value) external storageOnly {\r\n        data_bytes[key] = value;\r\n    }\r\n\r\n    /*** String ***/\r\n    function getString(bytes32 key) external view returns(string memory) {\r\n        return string(data_bytes[key]);\r\n    }\r\n\r\n    function setString(bytes32 key, string calldata value) external  storageOnly {\r\n        data_bytes[key] = bytes(value);\r\n    }\r\n\r\n    /*** Bytes Array ***/\r\n    function getBytesArray(bytes32 key)  external view returns (bytes32[] memory) {\r\n        return data_bytesArray[key];\r\n    }\r\n\r\n    function getBytesArrayIndex(bytes32 key, uint256 index)  external view returns (bytes32) {\r\n        return data_bytesArray[key][index];\r\n    }\r\n\r\n    function getBytesArrayLength(bytes32 key)  external view returns (uint256) {\r\n        return data_bytesArray[key].length;\r\n    }\r\n\r\n    function pushBytesArray(bytes32 key, bytes32 value)  external {\r\n        data_bytesArray[key].push(value);\r\n    }\r\n\r\n    function setBytesArrayIndex(bytes32 key, uint256 index, bytes32 value) external  storageOnly {\r\n        data_bytesArray[key][index] = value;\r\n    }\r\n\r\n    function setBytesArray(bytes32 key, bytes32[] calldata value) external  storageOnly {\r\n        data_bytesArray[key] = value;\r\n    }\r\n\r\n    /*** Int Array ***/\r\n    function getIntArray(bytes32 key) external  view returns (int[] memory) {\r\n        return data_intArray[key];\r\n    }\r\n\r\n    function getIntArrayIndex(bytes32 key, uint256 index) external  view returns (int) {\r\n        return data_intArray[key][index];\r\n    }\r\n\r\n    function getIntArrayLength(bytes32 key) external  view returns (uint256) {\r\n        return data_intArray[key].length;\r\n    }\r\n\r\n    function pushIntArray(bytes32 key, int value)  external {\r\n        data_intArray[key].push(value);\r\n    }\r\n\r\n    function setIntArrayIndex(bytes32 key, uint256 index, int value)  external storageOnly {\r\n        data_intArray[key][index] = value;\r\n    }\r\n\r\n    function setIntArray(bytes32 key, int[] calldata value)  external storageOnly {\r\n        data_intArray[key] = value;\r\n    }\r\n\r\n    /*** Address Array ***/\r\n    function getAddressArray(bytes32 key) external  view returns (address[] memory) {\r\n        return data_addressArray[key];\r\n    }\r\n\r\n    function getAddressArrayIndex(bytes32 key, uint256 index) external  view returns (address) {\r\n        return data_addressArray[key][index];\r\n    }\r\n\r\n    function getAddressArrayLength(bytes32 key) external view returns (uint256) {\r\n        return data_addressArray[key].length;\r\n    }\r\n\r\n    function pushAddressArray(bytes32 key, address value) external {\r\n        data_addressArray[key].push(value);\r\n    }\r\n\r\n    function setAddressArrayIndex(bytes32 key, uint256 index, address value)  external storageOnly {\r\n        data_addressArray[key][index] = value;\r\n    }\r\n\r\n    function setAddressArray(bytes32 key, address[] calldata value)  external storageOnly {\r\n        data_addressArray[key] = value;\r\n    }\r\n}\r\n"
    },
    "contracts/lib/platform/priceClient.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport './Client.sol';\r\nimport '../../platform/dispatch/DispatchInterface.sol';\r\nimport '../../platform/bondage/BondageInterface.sol';\r\nimport '../../platform/registry/RegistryInterface.sol';\r\nimport './OnChainProvider.sol';\r\nimport '../ERC20.sol';\r\nimport '../ownership/Ownable.sol';\r\n\r\ncontract priceClient is Ownable {\r\n    event MadeQuery(address oracle, string query, uint256 id);\r\n    event Result1(uint256 id, string response1);\r\n    event Result32(uint256 id, bytes32 response1);\r\n    event Result2(uint256 id, string response1, string response2);\r\n    event Result3(uint256 id, int256[] response3);\r\n\r\n    mapping(uint256 => string) public queryResults;\r\n    mapping(uint256 => bytes32[]) public queryBytes32Results;\r\n    //mapping(uint=>int[]) public queryIntResults;\r\n    uint256[] public priceResults;\r\n    uint256[] public priceTimeStamps;\r\n    uint256[] public priceQueryIDs;\r\n\r\n    mapping(uint256 => uint256) public queryBytes32IDs;\r\n    mapping(uint256 => uint256) public queryIntIDs;\r\n    mapping(uint256 => uint256) public queryIDs;\r\n\r\n    //** Oracle Details*/\r\n    address public oracle;\r\n    string public DataQuery;\r\n    bytes32 public querySpec;\r\n    bytes32[] public queryParams;\r\n\r\n    uint256 public totalQueries;\r\n    uint256 public totalIntQueries;\r\n    uint256 public totalBytes32Queries;\r\n\r\n    ERC20 token;\r\n    DispatchInterface dispatch;\r\n    BondageInterface bondage;\r\n    RegistryInterface registry;\r\n\r\n    constructor(\r\n        address tokenAddress,\r\n        address dispatchAddress,\r\n        address bondageAddress,\r\n        address registryAddress,\r\n        address oracleAddr,\r\n        string memory query,\r\n        bytes32 specifier,\r\n        bytes32[] memory params\r\n    ) public {\r\n        token = ERC20(tokenAddress);\r\n        dispatch = DispatchInterface(dispatchAddress);\r\n        bondage = BondageInterface(bondageAddress);\r\n        registry = RegistryInterface(registryAddress);\r\n        oracle = oracleAddr;\r\n        DataQuery = query;\r\n        querySpec = specifier;\r\n        queryParams = params;\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        require(\r\n            msg.sender == address(dispatch),\r\n            'caller must the dispatch address '\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*\r\n    Implements overloaded callback functions for Client1\r\n    */\r\n\r\n    function callback(uint256 id, int256[] calldata response)\r\n        external\r\n        onlyOracle()\r\n    {\r\n        require(\r\n            response.length == 1,\r\n            'int resoonse must have length of 1 for prices'\r\n        );\r\n        emit Result3(id, response);\r\n        priceResults.push(uint256(response[0]));\r\n        priceTimeStamps.push(block.timestamp);\r\n        priceQueryIDs.push(id);\r\n        //queryIntResults[id]=response;\r\n        // queryIntIDs[totalIntQueries]=id;\r\n        totalIntQueries++;\r\n        // do something with result\r\n    }\r\n\r\n    function initPriceQuery() external returns (uint256) {\r\n        uint256 id = dispatch.query(oracle, DataQuery, querySpec, queryParams);\r\n        emit MadeQuery(oracle, DataQuery, id);\r\n        return id;\r\n    }\r\n\r\n    function returnPriceQueries()\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        return (priceResults, priceTimeStamps, priceQueryIDs);\r\n    }\r\n\r\n    function latestPrice()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            priceResults[totalIntQueries - 1],\r\n            priceTimeStamps[totalIntQueries - 1],\r\n            priceQueryIDs[totalIntQueries - 1]\r\n        );\r\n    }\r\n\r\n    function updateQuery(\r\n        address oracleAddr,\r\n        string memory query,\r\n        bytes32 specifier,\r\n        bytes32[] memory params\r\n    ) public onlyOwner {\r\n        oracle = oracleAddr;\r\n        DataQuery = query;\r\n        querySpec = specifier;\r\n        queryParams = params;\r\n    }\r\n\r\n    function delegateBond() public onlyOwner {}\r\n\r\n    // attempts to cancel an existing query\r\n    function cancelQuery(uint256 id) external onlyOwner {\r\n        dispatch.cancelQuery(id);\r\n    }\r\n}\r\n"
    },
    "contracts/lib/platform/TestContracts.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport './Client.sol';\r\nimport '../../platform/dispatch/DispatchInterface.sol';\r\nimport '../../platform/bondage/BondageInterface.sol';\r\nimport '../../platform/registry/RegistryInterface.sol';\r\nimport './OnChainProvider.sol';\r\nimport '../ERC20.sol';\r\n\r\ncontract TestProvider is OnChainProvider {\r\n    event RecievedQuery(string query, bytes32 endpoint, bytes32[] params);\r\n\r\n    event TEST(uint256 res, bytes32 b, string s);\r\n\r\n    bytes32 public spec1 = 'Hello?';\r\n    bytes32 public spec2 = 'Reverse';\r\n    bytes32 public spec3 = 'Add';\r\n    bytes32 public spec4 = 'Double';\r\n\r\n    bool AM_A_BAD_ORACLE;\r\n\r\n    /* Endpoints to Functions:\r\n    spec1: Hello? -> returns \"Hello World\"\r\n    spec2: Reverse -> returns the query string in reverse\r\n    spec3: Add -> Adds up the values in endpointParams\r\n    */\r\n\r\n    // curve 2x^2\r\n    int256[] curve = [3, 0, 0, 2, 1000000000];\r\n\r\n    RegistryInterface registry;\r\n\r\n    // middleware function for handling queries\r\n    function receiveQuery(\r\n        uint256 id,\r\n        string calldata userQuery,\r\n        bytes32 endpoint,\r\n        bytes32[] calldata endpointParams,\r\n        bool onchainSubscriber\r\n    ) external {\r\n        emit RecievedQuery(userQuery, endpoint, endpointParams);\r\n        if (AM_A_BAD_ORACLE) return;\r\n        bytes32 _endpoint = endpoint;\r\n        if (onchainSubscriber) {\r\n            bytes32 hash = keccak256(abi.encodePacked(_endpoint));\r\n\r\n            if (hash == keccak256(abi.encodePacked(spec1))) {\r\n                endpoint1(id, userQuery, endpointParams);\r\n            } else if (hash == keccak256(abi.encodePacked(spec2))) {\r\n                endpoint2(id, userQuery, endpointParams);\r\n            } else if (hash == keccak256(abi.encodePacked(spec3))) {\r\n                endpoint3(id, userQuery, endpointParams);\r\n            } else if (hash == keccak256(abi.encodePacked(spec4))) {\r\n                endpoint4(id, userQuery, endpointParams);\r\n            } else {\r\n                revert('Invalid endpoint');\r\n            }\r\n        } // else: Do nothing (onchain only)\r\n    }\r\n\r\n    constructor(address registryAddress, bool isBad) public {\r\n        registry = RegistryInterface(registryAddress);\r\n        AM_A_BAD_ORACLE = isBad;\r\n\r\n        // initialize in registry\r\n        bytes32 title = 'TestContract';\r\n\r\n        bytes32[] memory params = new bytes32[](2);\r\n        params[0] = 'p1';\r\n        params[1] = 'p2';\r\n\r\n        registry.initiateProvider(12345, title);\r\n\r\n        registry.initiateProviderCurve(spec1, curve, address(0));\r\n        registry.initiateProviderCurve(spec2, curve, address(0));\r\n        registry.initiateProviderCurve(spec3, curve, address(0));\r\n        registry.initiateProviderCurve(spec4, curve, address(0));\r\n    }\r\n\r\n    // return Hello World to query-maker\r\n    function endpoint1(\r\n        uint256 id,\r\n        string memory, /* userQuery */\r\n        bytes32[] memory /* endpointParams */\r\n    ) internal {\r\n        DispatchInterface(msg.sender).respond1(id, 'Hello World');\r\n    }\r\n\r\n    // return the hash of the query\r\n    function endpoint2(\r\n        uint256 id,\r\n        string memory userQuery,\r\n        bytes32[] memory /* endpointParams */\r\n    ) internal {\r\n        // endpointParams\r\n        string memory reversed = reverseString(userQuery);\r\n        DispatchInterface(msg.sender).respond1(id, reversed);\r\n    }\r\n\r\n    // returns the sum of all values in endpointParams\r\n    function endpoint3(\r\n        uint256 id,\r\n        string memory, /* userQuery */\r\n        bytes32[] memory endpointParams\r\n    ) internal {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < endpointParams.length; i++) {\r\n            uint256 value = uint256(endpointParams[i]);\r\n            sum += value;\r\n        }\r\n\r\n        bytes32[] memory res = new bytes32[](1);\r\n        res[0] = bytes32(sum);\r\n\r\n        DispatchInterface(msg.sender).respondBytes32Array(id, res);\r\n    }\r\n\r\n    // returns the sum of all values in endpointParams\r\n    function endpoint4(\r\n        uint256 id,\r\n        string memory, /* userQuery */\r\n        bytes32[] memory /* endpointParams */\r\n    ) internal {\r\n        DispatchInterface(msg.sender).respond2(id, 'Hello', 'World');\r\n    }\r\n\r\n    function reverseString(string memory _base)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        string memory _tempValue = new string(_baseBytes.length);\r\n        bytes memory _newValue = bytes(_tempValue);\r\n\r\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\r\n            _newValue[_baseBytes.length - i - 1] = _baseBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }\r\n\r\n    function bytes32ToString(bytes32 data)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint256(data) * 2**(8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n}\r\n\r\n/* Test Subscriber Client */\r\ncontract TestClient is Client1, Client2 {\r\n    event MadeQuery(address oracle, string query, uint256 id);\r\n    event Result1(uint256 id, string response1);\r\n    event Result1(uint256 id, bytes32 response1);\r\n    event Result2(uint256 id, string response1, string response2);\r\n\r\n    ERC20 token;\r\n    DispatchInterface dispatch;\r\n    BondageInterface bondage;\r\n    RegistryInterface registry;\r\n\r\n    constructor(\r\n        address tokenAddress,\r\n        address dispatchAddress,\r\n        address bondageAddress,\r\n        address registryAddress\r\n    ) public {\r\n        token = ERC20(tokenAddress);\r\n        dispatch = DispatchInterface(dispatchAddress);\r\n        bondage = BondageInterface(bondageAddress);\r\n        registry = RegistryInterface(registryAddress);\r\n    }\r\n\r\n    /*\r\n    Implements overloaded callback functions for Client1\r\n    */\r\n    function callback(uint256 id, string calldata response1) external {\r\n        string memory _response1 = response1;\r\n        emit Result1(id, _response1);\r\n        // do something with result\r\n    }\r\n\r\n    function callback(uint256 id, bytes32[] calldata response) external {\r\n        emit Result1(id, response[0]);\r\n        // do something with result\r\n    }\r\n\r\n    // Client2 callback\r\n    function callback(\r\n        uint256 id,\r\n        string calldata response1,\r\n        string calldata response2\r\n    ) external {\r\n        emit Result2(id, response1, response2);\r\n        // do something with result\r\n    }\r\n\r\n    function testQuery(\r\n        address oracleAddr,\r\n        string calldata query,\r\n        bytes32 specifier,\r\n        bytes32[] calldata params\r\n    ) external returns (uint256) {\r\n        uint256 id = dispatch.query(oracleAddr, query, specifier, params);\r\n        emit MadeQuery(oracleAddr, query, id);\r\n        return id;\r\n    }\r\n\r\n    function stringToBytes32(string memory source)\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    // attempts to cancel an existing query\r\n    function cancelQuery(uint256 id) external {\r\n        dispatch.cancelQuery(id);\r\n    }\r\n}\r\n"
    },
    "contracts/lib/platform/OffChainClient.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport './Client.sol';\r\nimport '../../platform/dispatch/DispatchInterface.sol';\r\nimport '../../platform/bondage/BondageInterface.sol';\r\nimport '../../platform/registry/RegistryInterface.sol';\r\nimport './OnChainProvider.sol';\r\nimport '../ERC20.sol';\r\n\r\ncontract OffChainClient is Client1, Client2 {\r\n    event MadeQuery(address oracle, string query, uint256 id);\r\n    event Result1(uint256 id, string response1);\r\n    event Result32(uint256 id, bytes32 response1);\r\n    event Result2(uint256 id, string response1, string response2);\r\n    event Result3(uint256 id, int256[] response3);\r\n\r\n    mapping(uint256 => string) public queryResults;\r\n    mapping(uint256 => bytes32[]) public queryBytes32Results;\r\n    mapping(uint256 => int256[]) public queryIntResults;\r\n\r\n    mapping(uint256 => uint256) public queryBytes32IDs;\r\n    mapping(uint256 => uint256) public queryIntIDs;\r\n    mapping(uint256 => uint256) public queryIDs;\r\n\r\n    uint256 public totalQueries;\r\n    uint256 public totalIntQueries;\r\n    uint256 public totalBytes32Queries;\r\n\r\n    ERC20 token;\r\n    DispatchInterface dispatch;\r\n    BondageInterface bondage;\r\n    RegistryInterface registry;\r\n\r\n    constructor(\r\n        address tokenAddress,\r\n        address dispatchAddress,\r\n        address bondageAddress,\r\n        address registryAddress\r\n    ) public {\r\n        token = ERC20(tokenAddress);\r\n        dispatch = DispatchInterface(dispatchAddress);\r\n        bondage = BondageInterface(bondageAddress);\r\n        registry = RegistryInterface(registryAddress);\r\n        //Oracle =oracle;\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        require(\r\n            msg.sender == address(dispatch),\r\n            'caller must the dispatch address '\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*\r\n    Implements overloaded callback functions for Client1\r\n    */\r\n    function callback(uint256 id, string calldata response1)\r\n        external\r\n        onlyOracle()\r\n    {\r\n        //string memory _response1 = response1;\r\n        queryResults[id] = response1;\r\n        queryIDs[totalQueries] = id;\r\n        totalQueries++;\r\n        emit Result1(id, response1);\r\n        // do something with result\r\n    }\r\n\r\n    function Callback(uint256 id, string calldata response1)\r\n        external\r\n        onlyOracle()\r\n    {\r\n        string memory _response1 = response1;\r\n        emit Result1(id, _response1);\r\n        // do something with result\r\n    }\r\n\r\n    function callback(uint256 id, bytes32[] calldata response)\r\n        external\r\n        onlyOracle()\r\n    {\r\n        emit Result32(id, response[0]);\r\n        queryBytes32Results[id] = response;\r\n        queryBytes32IDs[totalBytes32Queries] = id;\r\n        totalBytes32Queries++;\r\n        // do something with result\r\n    }\r\n\r\n    function callback(uint256 id, int256[] calldata response)\r\n        external\r\n        onlyOracle()\r\n    {\r\n        emit Result3(id, response);\r\n        queryIntResults[id] = response;\r\n        queryIntIDs[totalIntQueries] = id;\r\n        totalIntQueries++;\r\n        // do something with result\r\n    }\r\n\r\n    // Client2 callback\r\n    function callback(\r\n        uint256 id,\r\n        string calldata response1,\r\n        string calldata response2\r\n    ) external onlyOracle() {\r\n        string memory concat = string(abi.encodePacked(response1, response2));\r\n        queryResults[id] = concat;\r\n        queryIDs[totalQueries] = id;\r\n        totalQueries++;\r\n        emit Result2(id, response1, response2);\r\n    }\r\n\r\n    function testQuery(\r\n        address oracleAddr,\r\n        string calldata query,\r\n        bytes32 specifier,\r\n        bytes32[] calldata params\r\n    ) external returns (uint256) {\r\n        uint256 id = dispatch.query(oracleAddr, query, specifier, params);\r\n        emit MadeQuery(oracleAddr, query, id);\r\n        return id;\r\n    }\r\n\r\n    function getQueryResultById(uint256 id)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return queryResults[id];\r\n    }\r\n\r\n    function getQueryIntResultById(uint256 id)\r\n        public\r\n        view\r\n        returns (int256[] memory)\r\n    {\r\n        return queryIntResults[id];\r\n    }\r\n\r\n    function getQueryResultByOrder(uint256 pos)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        uint256 id = queryIDs[pos];\r\n        return queryResults[id];\r\n    }\r\n\r\n    function getQueryIntResultByOrder(uint256 pos)\r\n        public\r\n        view\r\n        returns (int256[] memory)\r\n    {\r\n        uint256 id = queryIntIDs[pos];\r\n        return queryIntResults[id];\r\n    }\r\n\r\n    function getQueryBytes32ResultById(uint256 id)\r\n        public\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return queryBytes32Results[id];\r\n    }\r\n\r\n    function getQueryBytes32ResultByOrder(uint256 pos)\r\n        public\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        uint256 id = queryBytes32IDs[pos];\r\n        return queryBytes32Results[id];\r\n    }\r\n\r\n    function getQueryIntResultByData(\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        string memory query,\r\n        address subscriber,\r\n        address provider\r\n    ) public view returns (int256[] memory) {\r\n        uint256 id = uint256(\r\n            keccak256(\r\n                abi.encodePacked(block.number, now, query, subscriber, provider)\r\n            )\r\n        );\r\n        return queryIntResults[id];\r\n    }\r\n\r\n    function getQueryResultByData(\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        string memory query,\r\n        address subscriber,\r\n        address provider\r\n    ) public view returns (string memory) {\r\n        uint256 id = uint256(\r\n            keccak256(\r\n                abi.encodePacked(block.number, now, query, subscriber, provider)\r\n            )\r\n        );\r\n        return queryResults[id];\r\n    }\r\n\r\n    function getQueryBytesResultByData(\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        string memory query,\r\n        address subscriber,\r\n        address provider\r\n    ) public view returns (bytes32[] memory) {\r\n        uint256 id = uint256(\r\n            keccak256(\r\n                abi.encodePacked(block.number, now, query, subscriber, provider)\r\n            )\r\n        );\r\n        return queryBytes32Results[id];\r\n    }\r\n\r\n    function stringToBytes32(string memory source)\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    // attempts to cancel an existing query\r\n    function cancelQuery(uint256 id) external {\r\n        dispatch.cancelQuery(id);\r\n    }\r\n}\r\n"
    },
    "contracts/platform/arbiter/Arbiter.sol": {
      "content": "pragma solidity =0.5.16;\r\n// v1.0\r\n\r\nimport \"../../lib/ownership/Upgradable.sol\";\r\nimport \"../../lib/lifecycle/Destructible.sol\";\r\nimport \"../bondage/BondageInterface.sol\";\r\nimport \"./ArbiterInterface.sol\";\r\nimport \"../database/DatabaseInterface.sol\";\r\n\r\n\r\ncontract Arbiter is Destructible, ArbiterInterface, Upgradable {\r\n    // Called when a data purchase is initiated\r\n    event DataPurchase(\r\n        address indexed provider,          // Etheruem address of the provider\r\n        address indexed subscriber,        // Ethereum address of the subscriber\r\n        uint256 publicKey,                 // Public key of the subscriber\r\n        uint256 indexed amount,            // Amount (in 1/100 ZAP) of ethereum sent\r\n        bytes32[] endpointParams,          // Endpoint specific(nonce,encrypted_uuid),\r\n        bytes32 endpoint                   // Endpoint specifier\r\n    );\r\n\r\n    // Called when a data subscription is ended by either provider or terminator\r\n    event DataSubscriptionEnd(\r\n        address indexed provider,                      // Provider from the subscription\r\n        address indexed subscriber,                    // Subscriber from the subscription\r\n        SubscriptionTerminator indexed terminator      // Which terminated the contract\r\n    );\r\n\r\n    // Called when party passes arguments to another party\r\n    event ParamsPassed(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        bytes32 endpoint,\r\n        bytes32[] params\r\n    );\r\n\r\n    // Used to specify who is the terminator of a contract\r\n    enum SubscriptionTerminator { Provider, Subscriber }\r\n\r\n    BondageInterface bondage;\r\n    address public bondageAddress;\r\n\r\n    // database address and reference\r\n    DatabaseInterface public db;\r\n\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        bondageAddress = coordinator.getContract(\"BONDAGE\");\r\n        bondage = BondageInterface(bondageAddress);\r\n\r\n        address databaseAddress = coordinator.getContract(\"DATABASE\");\r\n        db = DatabaseInterface(databaseAddress);\r\n    }\r\n\r\n    //@dev broadcast parameters from sender to offchain receiver\r\n    /// @param receiver address\r\n    /// @param endpoint Endpoint specifier\r\n    /// @param params arbitrary params to be passed\r\n    function passParams(address receiver, bytes32 endpoint, bytes32[] memory params) public {\r\n        emit ParamsPassed(msg.sender, receiver, endpoint, params);\r\n    }\r\n\r\n    /// @dev subscribe to specified number of blocks of provider\r\n    /// @param providerAddress Provider address\r\n    /// @param endpoint Endpoint specifier\r\n    /// @param endpointParams Endpoint specific params\r\n    /// @param publicKey Public key of the purchaser\r\n    /// @param blocks Number of blocks subscribed, 1block=1dot\r\n    function initiateSubscription(\r\n        address providerAddress,   //\r\n        bytes32 endpoint,          //\r\n        bytes32[] memory endpointParams,  //\r\n        uint256 publicKey,         // Public key of the purchaser\r\n        uint64 blocks              //\r\n    )\r\n        public\r\n    {\r\n        // Must be atleast one block\r\n        require(blocks > 0, \"Error: Must be at least one block\");\r\n\r\n        // Can't reinitiate a currently active contract\r\n        require(getDots(providerAddress, msg.sender, endpoint) == 0, \"Error: Cannot reinstantiate a currently active contract\");\r\n\r\n        // Escrow the necessary amount of dots\r\n        bondage.escrowDots(msg.sender, providerAddress, endpoint, blocks);\r\n\r\n        // Initiate the subscription struct\r\n        setSubscription(\r\n            providerAddress,\r\n            msg.sender,\r\n            endpoint,\r\n            blocks,\r\n            uint96(block.number),\r\n            uint96(block.number) + uint96(blocks)\r\n        );\r\n\r\n        emit DataPurchase(\r\n            providerAddress,\r\n            msg.sender,\r\n            publicKey,\r\n            blocks,\r\n            endpointParams,\r\n            endpoint\r\n        );\r\n    }\r\n\r\n    /// @dev get subscription info\r\n    function getSubscription(address providerAddress, address subscriberAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (uint64 dots, uint96 blockStart, uint96 preBlockEnd)\r\n    {\r\n        return (\r\n            getDots(providerAddress, subscriberAddress, endpoint),\r\n            getBlockStart(providerAddress, subscriberAddress, endpoint),\r\n            getPreBlockEnd(providerAddress, subscriberAddress, endpoint)\r\n        );\r\n    }\r\n\r\n    /// @dev Finish the data feed from the provider\r\n    function endSubscriptionProvider(\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n    {\r\n        // Emit an event on success about who ended the contract\r\n        if (endSubscription(msg.sender, subscriberAddress, endpoint))\r\n            emit DataSubscriptionEnd(\r\n                msg.sender,\r\n                subscriberAddress,\r\n                SubscriptionTerminator.Provider\r\n            );\r\n    }\r\n\r\n    /// @dev Finish the data feed from the subscriber\r\n    function endSubscriptionSubscriber(\r\n        address providerAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n    {\r\n        // Emit an event on success about who ended the contract\r\n        if (endSubscription(providerAddress, msg.sender, endpoint))\r\n            emit DataSubscriptionEnd(\r\n                providerAddress,\r\n                msg.sender,\r\n                SubscriptionTerminator.Subscriber\r\n            );\r\n    }\r\n\r\n    /// @dev Finish the data feed\r\n    function endSubscription(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        private\r\n        returns (bool)\r\n    {\r\n        // get the total value/block length of this subscription\r\n        uint256 dots = getDots(providerAddress, subscriberAddress, endpoint);\r\n        uint256 preblockend = getPreBlockEnd(providerAddress, subscriberAddress, endpoint);\r\n        // Make sure the subscriber has a subscription\r\n        require(dots > 0, \"Error: Subscriber must have a subscription\");\r\n\r\n        if (block.number < preblockend) {\r\n            // Subscription ended early\r\n            uint256 earnedDots = block.number - getBlockStart(providerAddress, subscriberAddress, endpoint);\r\n            uint256 returnedDots = dots - earnedDots;\r\n\r\n            // Transfer the earned dots to the provider\r\n            bondage.releaseDots(\r\n                subscriberAddress,\r\n                providerAddress,\r\n                endpoint,\r\n                earnedDots\r\n            );\r\n            //  Transfer the returned dots to the subscriber\r\n            bondage.returnDots(\r\n                subscriberAddress,\r\n                providerAddress,\r\n                endpoint,\r\n                returnedDots\r\n            );\r\n        } else {\r\n            // Transfer all the dots\r\n            bondage.releaseDots(\r\n                subscriberAddress,\r\n                providerAddress,\r\n                endpoint,\r\n                dots\r\n            );\r\n        }\r\n        // Kill the subscription\r\n        deleteSubscription(providerAddress, subscriberAddress, endpoint);\r\n        return true;\r\n    }\r\n\r\n\r\n    /*** --- *** STORAGE METHODS *** --- ***/\r\n\r\n    /// @dev get subscriber dots remaining for specified provider endpoint\r\n    function getDots(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint64)\r\n    {\r\n        return uint64(db.getNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'dots'))));\r\n    }\r\n\r\n    /// @dev get first subscription block number\r\n    function getBlockStart(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint96)\r\n    {\r\n        return uint96(db.getNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'blockStart'))));\r\n    }\r\n\r\n    /// @dev get last subscription block number\r\n    function getPreBlockEnd(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint96)\r\n    {\r\n        return uint96(db.getNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'preBlockEnd'))));\r\n    }\r\n\r\n    /**** Set Methods ****/\r\n\r\n    /// @dev store new subscription\r\n    function setSubscription(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint,\r\n        uint64 dots,\r\n        uint96 blockStart,\r\n        uint96 preBlockEnd\r\n    )\r\n        private\r\n    {\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'dots')), dots);\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'blockStart')), uint256(blockStart));\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'preBlockEnd')), uint256(preBlockEnd));\r\n    }\r\n\r\n    /**** Delete Methods ****/\r\n\r\n    /// @dev remove subscription\r\n    function deleteSubscription(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        private\r\n    {\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'dots')), 0);\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'blockStart')), uint256(0));\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'preBlockEnd')), uint256(0));\r\n    }\r\n}\r\n\r\n    /*************************************** STORAGE ****************************************\r\n    * 'holders', holderAddress, 'initialized', oracleAddress => {uint256} 1 -> provider-subscriber initialized, 0 -> not initialized\r\n    * 'holders', holderAddress, 'bonds', oracleAddress, endpoint => {uint256} number of dots this address has bound to this endpoint\r\n    * 'oracles', oracleAddress, endpoint, 'broker' => {address} address of endpoint broker, 0 if none\r\n    * 'escrow', holderAddress, oracleAddress, endpoint => {uint256} amount of Zap that have been escrowed\r\n    * 'totalBound', oracleAddress, endpoint => {uint256} amount of Zap bound to this endpoint\r\n    * 'totalIssued', oracleAddress, endpoint => {uint256} number of dots issued by this endpoint\r\n    * 'holders', holderAddress, 'oracleList' => {address[]} array of oracle addresses associated with this holder\r\n    ****************************************************************************************/\r\n"
    },
    "contracts/platform/arbiter/ArbiterInterface.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract ArbiterInterface {\r\n    function initiateSubscription(address, bytes32, bytes32[] memory, uint256, uint64)  public;\r\n    function getSubscription(address, address, bytes32)  public view returns (uint64, uint96, uint96);\r\n    function endSubscriptionProvider(address, bytes32)  public;\r\n    function endSubscriptionSubscriber(address, bytes32)  public;\r\n    function passParams(address receiver, bytes32 endpoint, bytes32[] memory params)  public;\r\n}\r\n"
    },
    "contracts/lib/ownership/ZapCoordinator.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nimport \"./Upgradable.sol\";\r\nimport \"./ZapCoordinatorInterface.sol\";\r\nimport \"../../platform/database/DatabaseInterface.sol\";\r\n\r\ncontract ZapCoordinator is ZapCoordinatorInterface {\r\n\r\n    event UpdatedContract(string name, address previousAddr, address newAddr);\r\n    event UpdatedDependencies(uint timestamp, string contractName, address contractAddr);\r\n\r\n    mapping(string => address) contracts;\r\n\r\n    // names of upgradable contracts\r\n    string[] public loadedContracts;\r\n\r\n    DatabaseInterface public db;\r\n\r\n    // used for adding contracts like Database and ZapToken\r\n    function addImmutableContract(string calldata contractName, address newAddress) external onlyOwner {\r\n        assert(contracts[contractName] == address(0));\r\n        contracts[contractName] = newAddress;\r\n\r\n        // Create DB object when Database is added to Coordinator\r\n        bytes32 hash = keccak256(abi.encodePacked(contractName));\r\n        if (hash == keccak256(abi.encodePacked(\"DATABASE\"))) db = DatabaseInterface(newAddress);\r\n    }\r\n\r\n    // used for modifying an existing contract or adding a new contract to the system\r\n    function updateContract(string calldata contractName, address newAddress) external onlyOwner {\r\n        address prev = contracts[contractName];\r\n        if (prev == address(0) ) {\r\n            // First time adding this contract\r\n            loadedContracts.push(contractName);\r\n        } else {\r\n            // Deauth the old contract\r\n            db.setStorageContract(prev, false);\r\n        }\r\n        // give new contract database access permission\r\n        db.setStorageContract(newAddress, true);\r\n\r\n        emit UpdatedContract(contractName, prev, newAddress);\r\n        contracts[contractName] = newAddress;\r\n    }\r\n\r\n    function getContractName(uint index) public view returns (string memory) {\r\n        return loadedContracts[index];\r\n    }\r\n\r\n    function getContract(string memory contractName) public view returns (address) {\r\n        return contracts[contractName];\r\n    }\r\n\r\n    function updateAllDependencies() external onlyOwner {\r\n        for (uint i = 0; i < loadedContracts.length; i++) {\r\n            address c = contracts[loadedContracts[i]];\r\n            Upgradable(c).updateDependencies();\r\n            emit UpdatedDependencies(block.timestamp, loadedContracts[i], c);\r\n        }\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/lib/platform/GenericERC721Sale.sol": {
      "content": "\r\npragma solidity =0.5.16;\r\n// Replace with 721 Interface\r\n//import \"../token/FactoryTokenInterface.sol\";\r\nimport \"../ownership/ZapCoordinatorInterface.sol\";\r\nimport \"../../platform/bondage/BondageInterface.sol\";\r\nimport \"../../platform/bondage/currentCost/CurrentCostInterface.sol\";\r\nimport \"../../platform/registry/RegistryInterface.sol\";\r\nimport \"../../platform/bondage/currentCost/CurrentCostInterface.sol\";\r\nimport \"../token/FactoryTokenInterface.sol\";\r\ninterface NFTTokenInterface  {\r\n\r\n           event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n           event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n           event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n           function mint(address to,uint256 tokenId) external;\r\n           function burnFrom(uint256 tokenId) external;\r\n           function balanceOf(address _owner) external view returns (uint256);\r\n           function ownerOf(uint256 _tokenId) external view returns (address);\r\n           function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\r\n           function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n           function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n           function setApprovalForAll(address _operator, bool _approved) external;\r\n           function getApproved(uint256 _tokenId) external view returns (address);\r\n           function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n           function setBaseURI(string calldata baseMetadata) external;\r\n           function setURI(uint256 tokenId,string calldata uri) external;\r\n}\r\ninterface TokenFactoryInterface{\r\n    function create(string calldata _name, string calldata _symbol) external returns (NFTTokenInterface);\r\n}\r\ncontract ERC721DotFactory {\r\n    address[] public deployedFactories;\r\n    address public coordinator;\r\n    address public factory;\r\n    event newDotFactory(address dotfactory,uint PubKey,bytes32 Title );\r\n\r\n    constructor(address _coordinator,address _factory) public {\r\n        coordinator=_coordinator;\r\n        factory=_factory;\r\n    }\r\n    function deployFactory(uint256 providerPubKey,bytes32 providerTitle ) public returns(address){\r\n        NFTDotTokenFactory TDF=  new NFTDotTokenFactory(coordinator,factory,providerPubKey,providerTitle);\r\n        TDF.transferOwnership(msg.sender);\r\n        deployedFactories.push(address(TDF));\r\n        emit newDotFactory(address(TDF),providerPubKey,providerTitle);\r\n        return address(TDF);\r\n    }\r\n    function getFactories() public view returns(address[] memory){\r\n        return deployedFactories;\r\n    }\r\n}\r\n\r\ncontract NFTDotTokenFactory is Ownable {\r\n\r\n    CurrentCostInterface currentCost;\r\n    FactoryTokenInterface public reserveToken;\r\n    ZapCoordinatorInterface public coord;\r\n    TokenFactoryInterface public tokenFactory;\r\n    BondageInterface bondage;\r\n    NFTTokenInterface public ERC721;\r\n    mapping(bytes32 => address) public curves;\r\n    mapping(bytes32=>uint256) public tokensMinted;\r\n    mapping(bytes32=>bool) public whitelistedCurve; \r\n    mapping(address=>mapping(bytes32=>string)) public whitelisting;\r\n\r\n    mapping(bytes32 => uint) public curvesTokenPrice;// map of endpoint specifier to token-backed dotaddress\r\n    bytes32[] public curves_list; // array of endpoint specifiers\r\n    event DotTokenCreated(address tokenAddress);\r\n\r\n    constructor(\r\n        address coordinator, \r\n        address factory,\r\n        uint256 providerPubKey,\r\n        bytes32 providerTitle\r\n        \r\n    ) public {\r\n        coord = ZapCoordinatorInterface(coordinator); \r\n        reserveToken = FactoryTokenInterface(coord.getContract(\"ZAP_TOKEN\"));\r\n        //always allow bondage to transfer from wallet\r\n        \r\n        reserveToken.approve(coord.getContract(\"BONDAGE\"), ~uint256(0));\r\n        tokenFactory = TokenFactoryInterface(factory);\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        registry.initiateProvider(providerPubKey, providerTitle);\r\n    }\r\n    //set nft price add price unit specifier\r\n    // tokenuri string\r\n    function initializeCurve(\r\n        bytes32 specifier, \r\n        bytes32 symbol, \r\n        int256[] memory curve,\r\n        uint price,\r\n        string memory baseMetadata,\r\n        bool whitelisted\r\n    ) public  onlyOwner returns(address) {\r\n        \r\n        require(curves[specifier] == address(0), \"Curve specifier already exists\");\r\n        \r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        require(registry.isProviderInitiated(address(this)), \"Provider not intiialized\");\r\n        whitelistedCurve[specifier]=whitelisted;\r\n        registry.initiateProviderCurve(specifier, curve, address(this));\r\n        curves[specifier] = newToken(bytes32ToString(specifier), bytes32ToString(symbol));\r\n        curves_list.push(specifier);\r\n        curvesTokenPrice[specifier]=price;\r\n        registry.setProviderParameter(specifier, toBytes(curves[specifier]));\r\n        ERC721.setBaseURI(baseMetadata);\r\n        emit DotTokenCreated(curves[specifier]);\r\n        return curves[specifier];\r\n    }\r\n    function whitelistBonder(bytes32  specifier,address bonder,string memory uri) public onlyOwner{\r\n        require(whitelistedCurve[specifier]==true,\"curve must be  whitelisted\");\r\n        whitelisting[bonder][specifier]=uri;\r\n    }\r\n\r\n    event Bonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); \r\n    //function approveForBond(address user, string memory metadata) public onlyOwner;\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n   \r\n    // needs nft price \r\n    function bondWhiteListed(bytes32 specifier) public  {\r\n        require(whitelistedCurve[specifier]==true,\"curve must be  whitelisted\");\r\n        uint numDots=curvesTokenPrice[specifier];\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 issued = bondage.getDotsIssued(address(this), specifier);\r\n\r\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint256 numReserve = cost._costOfNDots(address(this), specifier, issued + 1, numDots - 1);\r\n\r\n        require(\r\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\r\n            \"insufficient accepted token numDots approved for transfer\"\r\n        );\r\n        require(bytes(whitelisting[msg.sender][specifier]).length>0,\"user must be whitelisted for metadata\");\r\n\r\n        uint id= uint(keccak256(abi.encodePacked(specifier)))+tokensMinted[specifier];\r\n\r\n        reserveToken.approve(address(bondage), numReserve);\r\n        bondage.bond(address(this), specifier, numDots);\r\n\r\n        NFTTokenInterface(curves[specifier]).mint(msg.sender, id);\r\n        NFTTokenInterface(curves[specifier]).setURI(id,whitelisting[msg.sender][specifier]);\r\n        whitelisting[msg.sender][specifier]=\"\";\r\n\r\n        emit Bonded(specifier, numDots, msg.sender);\r\n\r\n    }\r\n      function bond(bytes32 specifier) public  {\r\n        uint numDots=curvesTokenPrice[specifier];\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 issued = bondage.getDotsIssued(address(this), specifier);\r\n        require(whitelistedCurve[specifier]==false,\"curve must be not whitelisted\");\r\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint256 numReserve = cost._costOfNDots(address(this), specifier, issued + 1, numDots - 1);\r\n\r\n        require(\r\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\r\n            \"insufficient accepted token numDots approved for transfer\"\r\n        );\r\n        require(bytes(whitelisting[msg.sender][specifier]).length>0,\"user must be whitelisted for metadata\");\r\n\r\n        uint id= uint(keccak256(abi.encodePacked(specifier)))+tokensMinted[specifier];\r\n\r\n        reserveToken.approve(address(bondage), numReserve);\r\n        bondage.bond(address(this), specifier, numDots);\r\n\r\n        NFTTokenInterface(curves[specifier]).mint(msg.sender, id);\r\n       // NFTTokenInterface(curves[specifier]).setURI(id,whitelisting[msg.sender][specifier]);\r\n        //whitelisting[msg.sender][specifier]=\"\";\r\n\r\n        emit Bonded(specifier, numDots, msg.sender);\r\n\r\n    }\r\n    event Unbonded(bytes32 indexed specifier, uint256 indexed numDots, address indexed sender); \r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function unbond(bytes32 specifier, uint tokenID) public {\r\n        uint numDots=curvesTokenPrice[specifier];\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint issued = bondage.getDotsIssued(address(this), specifier);\r\n\r\n        currentCost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint reserveCost = currentCost._costOfNDots(address(this), specifier, issued + 1 - numDots, numDots - 1);\r\n       \r\n        //unbond dots\r\n        bondage.unbond(address(this), specifier, numDots);\r\n        //burn dot backed token\r\n        NFTTokenInterface  curveToken = NFTTokenInterface(curves[specifier]);\r\n        require(curveToken.ownerOf(tokenID) == msg.sender,\"token must be owned by sender\");\r\n        curveToken.burnFrom( tokenID);\r\n\r\n        require(reserveToken.transfer(msg.sender, reserveCost), \"Error: Transfer failed\");\r\n        emit Unbonded(specifier, numDots, msg.sender);\r\n\r\n    }\r\n\r\n    function newToken(\r\n        string  memory name,\r\n        string memory symbol\r\n    ) \r\n        public\r\n        onlyOwner\r\n        returns (address tokenAddress) \r\n    {\r\n        NFTTokenInterface token = tokenFactory.create(name, symbol);\r\n        tokenAddress = address(token);\r\n        return tokenAddress;\r\n    }\r\n\r\n    function getTokenAddress(bytes32 endpoint) public view returns(address) {\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n       // console.log(registry.getProviderParameter(address(this), endpoint));\r\n        return toAddress(registry.getProviderParameter(address(this), endpoint),0);\r\n    }\r\n\r\n    function getEndpoints() public view returns(bytes32[] memory ){\r\n      return curves_list;\r\n    }\r\n\r\n    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\r\n    function toBytes(address x) public pure returns (bytes memory b) {\r\n        b = new bytes(20);\r\n        for (uint i = 0; i < 20; i++)\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\r\n    function bytes32ToString(bytes32 x) public pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n\r\n        bytesString = abi.encodePacked(x);\r\n\r\n        return string(bytesString);\r\n    }\r\n\r\n    \r\n    function toAddress(bytes memory _bytes, uint256 _start) internal view returns (address) {\r\n        require(_start + 20 >= _start, \"toAddress_overflow\");\r\n        //console.log(_bytes.length);\r\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/MPO/lib/Destructible.sol": {
      "content": "\r\npragma solidity =0.5.16;\r\n\r\n\r\nimport \"./Ownable.sol\";\r\n\r\ncontract Destructible is Ownable {\r\n\tfunction selfDestruct() public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n}\r\n"
    },
    "contracts/MPO/lib/Ownable.sol": {
      "content": "\r\n\r\n\r\n\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n\r\n       require(newOwner != address(0));\r\n       emit OwnershipTransferred(owner, newOwner);\r\n       owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/MPO/MultiPartyOracle.sol": {
      "content": "\r\npragma solidity =0.5.16;\r\n\r\nimport \"./MPOStorage.sol\";\r\nimport \"./lib/Destructible.sol\";\r\nimport \"./lib/ZapInterface.sol\";\r\n// import \"./ECRecovery.sol\";\r\n// @title - A MultiPartyOracle contract that implements the client1 callback\r\n// @authors - Max Inciong, Jonathan Pang, Jon Morales\r\n// @notice the contract receives queries from dispatch and queries multiple providers to resolve the query\r\n\r\ncontract MultiPartyOracle {\r\n    event RecievedQuery(string query, bytes32 endpoint, bytes32[] params, address sender);\r\n    event ReceivedResponse(uint256 queryId, address responder, string response);\r\n    event Incoming(\r\n        uint256 id,\r\n        address provider,\r\n        address subscriber,\r\n        string query,\r\n        bytes32 endpoint,\r\n        bytes32[] endpointParams,\r\n        bool onchainSubscriber\r\n    );\r\n\r\n    event Result1(uint256 id, string response1);\r\n\r\n    ZapInterface dispatch;\r\n    ZapInterface bondage;\r\n    ZapInterface registry;\r\n    ZapInterface ztoken;\r\n    MPOStorage stor;\r\n    \r\n    //move dispatch address to storage\r\n    address dispatchAddress;\r\n    address bondageAddress;\r\n    address registryAddress;\r\n    address ztokenAddress;\r\n    address public storageAddress;\r\n    address aggregator; \r\n\r\n    bytes32 public spec3 = \"Nonproviders\";\r\n    int256[] curve3 = [1,1,1000000000];\r\n    uint numTrue = 0;\r\n    uint numFalse = 0;\r\n    // @notice constructor that sets up zap registry, dispatch, and MPO storage. Also sets up registry provider curve\r\n    // @param address registryAddress\r\n    // @param address _dispatchAddress\r\n    // @param address mpoStorageAddress\r\n    constructor(address _zapCoord, address mpoStorageAddress) public {\r\n        // require(_responders.length<=stor.getNumResponders(), \"Soft Cap reached\");\r\n        registryAddress = ZapInterface(_zapCoord).getContract(\"REGISTRY\");\r\n        registry = ZapInterface(registryAddress);\r\n        dispatchAddress = ZapInterface(_zapCoord).getContract(\"DISPATCH\");\r\n        dispatch = ZapInterface(dispatchAddress);\r\n        bondageAddress = ZapInterface(_zapCoord).getContract(\"BONDAGE\");\r\n        bondage = ZapInterface(bondageAddress);\r\n        ztokenAddress = ZapInterface(_zapCoord).getContract(\"ZAP_TOKEN\");\r\n        ztoken = ZapInterface(ztokenAddress);\r\n        stor = MPOStorage(mpoStorageAddress);\r\n    }\r\n\r\n   \r\n\r\n    function setup(address[] memory _responders) public{\r\n\r\n        stor.setResponders(_responders);\r\n        bytes32 title = \"MultiPartyOracle\";\r\n        registry.initiateProvider(12345, title);\r\n        registry.initiateProviderCurve(spec3, curve3, address(0));\r\n\r\n    }\r\n    \r\n    // middleware function for handling queries\r\n    // @notice recieves query, called from dispatch\r\n    // @param uint256 id Dispatch created query ID\r\n    // @param string userQuery User provided query String\r\n    // @param bytes32 endpoint Determines whether to use Onchain Providers, Offchain Providers, Non-Providers\r\n    // @param bytes32[] endpointParams Parameters passed to providers\r\n    // @param bool onchainSubscriber Unused boolean that determines if subscriber is a smart contract\r\n\r\n    \r\n\r\n    function receiveQuery(uint256 id, string calldata userQuery, bytes32 endpoint, bytes32[] calldata endpointParams, bool onchainSubscriber) external {\r\n\r\n        emit RecievedQuery(userQuery, endpoint, endpointParams, msg.sender);\r\n        require(msg.sender == dispatchAddress && stor.getQueryStatus(id) == 0, \"Dispatch only\");\r\n        // endpoint params [from, to, threshold, precision, delta]\r\n        bytes32 hash = keccak256(abi.encodePacked(endpoint));\r\n        uint256 threshold = uint(endpointParams[2]);\r\n        require(threshold > 0 && threshold <= stor.getNumResponders(),\"Invalid Threshold Length\");\r\n        stor.setThreshold(id, threshold );\r\n        \r\n        if(hash == keccak256(abi.encodePacked(spec3))) {\r\n            stor.setQueryStatus(id,1);\r\n            uint256 mpoid;\r\n            for(uint i=0; i<stor.getNumResponders(); i++) {      \r\n                mpoid=uint256(keccak256(abi.encodePacked(\r\n                                block.number, block.timestamp, userQuery,id,stor.getResponderAddress(i)\r\n                                )));\r\n                stor.setClientQueryId(mpoid, id);\r\n\r\n                emit Incoming(mpoid, stor.getResponderAddress(i),address(this), userQuery, \"Hello?\", endpointParams, true);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    // @notice callback used by dispatch or nonproviders once a response has been created for the query\r\n    // @param queryId MPO or dispatch generated MPOID to used to determine client query ID\r\n    // @param response Response to be returned to client\r\n    // @param msgHash, sigv, sigr, sigs to be used in ecrecover\r\n    // @dev \r\n  \r\n    function callback(uint256 mpoId, uint256[] calldata responses, bytes32[] calldata msgHash, uint8[] calldata sigv, bytes32[] calldata sigrs) external {\r\n\r\n        // require(msg.sender == aggregator, \"Invalid aggregator\");\r\n        \r\n        uint256 queryId = stor.getClientQueryId(mpoId);\r\n        address sender;\r\n        \r\n        for(uint i=0;i<msgHash.length;i++){\r\n            sender = ecrecover(msgHash[i],sigv[i],sigrs[2*i],sigrs[2*i+1]);\r\n            // If address is in whitelist\r\n            if( stor.getAddressStatus(sender) && !stor.onlyOneResponse(queryId,sender)){\r\n                    if(responses[i]!=0){\r\n                        numTrue++;\r\n                    }\r\n                    else{\r\n                        numFalse++;\r\n                    }\r\n                    stor.addResponse(queryId,sender);\r\n                }\r\n        }\r\n        \r\n        // Query status 0 = not started, 1 = in progress, 2 = complete\r\n        if(stor.getQueryStatus(queryId) == 1) {\r\n            // If enough answers meet the threshold send back the average of the answers\r\n            int256[] memory response=new int256[](1);\r\n            if(numTrue>numFalse && numTrue >= stor.getThreshold(queryId)){                \r\n                stor.setQueryStatus(queryId, 2);\r\n                response[0]=1;\r\n                return;\r\n            }\r\n            if(numFalse>numTrue && numFalse >= stor.getThreshold(queryId)){\r\n                stor.setQueryStatus(queryId, 2);\r\n                response[0]=0;\r\n                dispatch.respondIntArray(queryId, response);\r\n                return;\r\n            }\r\n        }\r\n        \r\n\r\n    }\r\n    mapping(address => uint) credits;\r\n    uint payoutTally = 0;\r\n    function payout() external {\r\n        require(stor.getAddressStatus(msg.sender), \"Invalid Voter\");\r\n        payoutTally++;\r\n        \r\n        if(payoutTally > stor.getNumResponders()/2){\r\n            uint payoutVal = bondage.getBoundDots(address(this),address(this),\"Nonproviders\");\r\n            require(payoutVal>0, \"No dots bound\");\r\n            bondage.unbond(address(this),\"Nonproviders\",payoutVal);\r\n            payoutVal = ztoken.balanceOf(address(this))/stor.getNumResponders();\r\n            address[] memory payArr = stor.getResponders();\r\n            for(uint i=0; i<stor.getNumResponders(); i++) {\r\n                credits[payArr[i]] += payoutVal;\r\n                // require(ztoken.transfer(payArr[i],payout), \"Failed to Tranfer Token\");\r\n            }\r\n            payoutTally=0;\r\n        }\r\n        \r\n        \r\n\r\n    }\r\n\r\n    function withdrawBalance() public {\r\n        uint amount = credits[msg.sender];\r\n\r\n        require(amount != 0, \"No payout available\");\r\n        require(ztoken.balanceOf(address(this)) >= amount, \"Not enough funds in contract\");\r\n\r\n        credits[msg.sender] = 0;\r\n\r\n        require(ztoken.transfer(msg.sender, amount), \"Failed to Tranfer Token\");\r\n    }\r\n\r\n  }\r\n    \r\n\r\n"
    },
    "contracts/MPO/MPOStorage.sol": {
      "content": "\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\nimport \"./lib/Ownable.sol\";\r\n\r\ncontract MPOStorage is Ownable{\r\n\r\n\r\n\t// check if msg.sender is in global approved list of responders\r\n\tmapping(address => bool) approvedAddress; \r\n\tmapping(uint256 => mapping(address => bool) ) isThresholdReached; \r\n\tmapping(uint256 => bool ) thresholdReached; \r\n\t// Threshold reached, do not accept any more responses\r\n\tmapping(uint256 => uint256) queryStatus;\r\n\t// Tally of each response.\r\n\tmapping(uint256 => mapping(uint256 => uint256) ) responseTally; \r\n\tmapping(uint256 => mapping(address => uint256) ) addressResponse; \r\n\tmapping(uint256 => mapping(address => uint256) ) addressTally; \r\n\tmapping(uint256 => uint256[]) responseArr; \r\n\tmapping(uint256 => uint256[]) thresholdArr;\r\n\tmapping(uint256 => uint256) average;\r\n\t// Make sure each party can only submit one response\r\n\tmapping(uint256 => mapping(address => bool)) oneAddressResponse; \r\n\tmapping(uint256 => uint256) mpoToClientId;\r\n\t\r\n\tmapping(uint256 => uint256) precision; \r\n\tmapping(uint256 => uint256) delta; \r\n\r\n\tmapping(uint256 => uint256) threshold;\r\n\taddress[] responders;\r\n\tuint256 responderLength = 5;\r\n\t// implements Client1\r\n\taddress client;\r\n\tuint256 clientQueryId; \r\n\r\n\r\n\t// Set Methods / Mutators\r\n\tfunction setThreshold(uint queryId, uint256 _threshold) external onlyOwner {\r\n\t\tthreshold[queryId] = _threshold;\r\n\t}\r\n\r\n\tfunction setClientQueryId(uint256 mpoId, uint256 _clientQueryId) external onlyOwner {\r\n\t\tmpoToClientId[mpoId] = _clientQueryId;\r\n\t}\r\n \r\n\r\n\tfunction setResponders(address[] calldata parties) external  onlyOwner{\r\n\r\n\t\tresponders=parties;\r\n\t\tif(responderLength>parties.length){\r\n\t\t\tresponderLength = parties.length;\r\n\t\t}\r\n\t\tfor(uint256 i=0; i <responderLength; i++){\r\n\t\t\tapprovedAddress[responders[i]]=true;\r\n\t\t}\r\n\t}\r\n\tfunction reachedThreshold(uint256 queryId, address sender) external  onlyOwner{\r\n\t\tisThresholdReached[queryId][sender] = true;\r\n\t\tthresholdReached[queryId] = true;\r\n\t}\r\n\tfunction setQueryStatus(uint queryId, uint256 status) external onlyOwner {\r\n\t\tqueryStatus[queryId]=status;\r\n\t}\r\n\r\n\tfunction tallyResponse(uint256 queryId, uint response) external onlyOwner {\r\n\t\tresponseTally[queryId][response]++;\r\n\r\n\t}\r\n\tfunction tallyAddress(uint256 queryId, address responder) external onlyOwner {\r\n\t\taddressTally[queryId][responder]++;\r\n\r\n\t}\r\n\tfunction addResponse(uint256 queryId, address party) external onlyOwner {\r\n\t\t// responseArr[queryId].push(response);\r\n\t\t// addressTally[queryId][party]++;\r\n\t\t// addressResponse[queryId][party] = response;\r\n\t\toneAddressResponse[queryId][party] = true;\r\n\t}\r\n\tfunction addThresholdResponse(uint256 queryId, uint256 response) external onlyOwner {\r\n\t\tthresholdArr[queryId].push(response);\r\n\t}\r\n\tfunction setDelta(uint256 queryId, uint256 _delta) external{\r\n\t\tdelta[queryId] = _delta;\r\n\t}\r\n\r\n\tfunction setPrecision(uint256 queryId, uint256 _precision) external{\r\n\t\tprecision[queryId] = _precision;\r\n\t}\r\n\t// Get Methods / Accessors\r\n\r\n\tfunction onlyOneResponse(uint256 queryId, address party) external view returns(bool) {\r\n        return oneAddressResponse[queryId][party];\r\n    }\r\n    function getThresholdStatus(uint256 queryId, address party) external view returns(bool) {\r\n        return isThresholdReached[queryId][party];\r\n    }\r\n\r\n    function getAddressStatus(address party) external view returns(bool){\r\n        return approvedAddress[party];\r\n    }\r\n\t\r\n\tfunction getThreshold(uint queryId) external view returns(uint) { \r\n\t\treturn threshold[queryId];\r\n\t}\r\n\t\r\n\tfunction getTally(uint256 queryId, uint256 response)external view returns(uint256){\r\n\t\treturn responseTally[queryId][response];\r\n\t}\r\n\tfunction getAddressTally(uint256 queryId, address responder)external view returns(uint256){\r\n\t\treturn addressTally[queryId][responder];\r\n\t}\r\n\tfunction getAddressResponse(uint256 queryId, address responder)external view returns(uint256){\r\n\t\treturn addressResponse[queryId][responder];\r\n\t}\r\n\t\r\n\tfunction getClientQueryId(uint256 mpoId) external view returns(uint256){\r\n\t\treturn mpoToClientId[mpoId];\r\n\t}\r\n\r\n\tfunction getQueryStatus(uint256 queryId) external view returns(uint256){\r\n\t\treturn queryStatus[queryId];\r\n\t}\r\n\r\n\r\n\r\n\r\n\tfunction getThresholdResponses(uint256 queryId) external view returns(uint256[] memory ){\r\n\r\n\t\treturn thresholdArr[queryId];\r\n\t}\r\n\r\n\tfunction getNumResponders() external view returns (uint) {\r\n\t\treturn responderLength;\r\n\t}\r\n\r\n\tfunction getResponderAddress(uint index) external view returns(address){\r\n\t\treturn responders[index];\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction getResponders() external view returns (address[] memory){\r\n\t\treturn responders;\r\n\t}\r\n\tfunction getResponses(uint256 queryId) external view returns(uint256[] memory){\r\n\r\n\t\treturn responseArr[queryId];\r\n\t}\r\n\tfunction getDelta(uint256 queryId) external view returns(uint256){\r\n\t\treturn delta[queryId];\r\n\t}\r\n\tfunction getPrecision(uint256 queryId) external view returns(uint256){\r\n\t\treturn precision[queryId];\r\n\t}\r\n\tfunction getQueryThreshold(uint queryId)external view returns(bool){\r\n\t\treturn thresholdReached[queryId];\r\n\t}\r\n\r\n\tfunction getAverage(uint256 queryId) external view returns(int[] memory ){\r\n\r\n\t\trequire(responders.length!=0, \"Division error\");\r\n\t\tuint total = 0;\r\n\t\tuint len=0;\r\n\t\t\r\n\t\tfor (uint i =0; i < responderLength ;i++){\r\n\t\t\tif(isThresholdReached[queryId][responders[i]] ){\r\n\t\t\t\tlen++;\r\n\t\t\t\ttotal+=addressResponse[queryId][responders[i]];\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(total<uint(2**256-1), \"Overflow error(getAverage)\");\r\n\t\tint[] memory avg = new int[](1);\r\n\t\tavg[0]=int(total) / int(len);\r\n\t\treturn avg;\r\n\t}\r\n\t\r\n\r\n}\r\n"
    },
    "contracts/MPO/lib/ZapInterface.sol": {
      "content": "\r\npragma solidity =0.5.16;\r\n\r\n\r\n contract ZapInterface{\r\n    //event\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function getContract(string memory contractName)  public view returns (address); \r\n    //registry\r\n    function initiateProvider(uint256, bytes32)  public returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[] memory,address)  public returns (bool);\r\n\r\n\r\n    function bond(address, bytes32, uint256)  external returns(uint256);\r\n    function unbond(address, bytes32, uint256)  external returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256)  external returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256)  external returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256)  external returns (bool);\r\n    function returnDots(address, address, bytes32, uint256)  external returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256)  external view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256)  public view returns (uint256);\r\n    function getDotsIssued(address, bytes32)  public view returns (uint256);\r\n    function getBoundDots(address, address, bytes32)  public view returns (uint256);\r\n    function getZapBound(address, bytes32)  public view returns (uint256);\r\n    function dotLimit( address, bytes32)  public view returns (uint256);\r\n\r\n    function query(address, string calldata, bytes32, bytes32[] calldata)  external returns (uint256); \r\n    function respond1(uint256, string calldata)  external returns (bool);\r\n    function respond2(uint256, string calldata, string calldata)  external returns (bool);\r\n    function respond3(uint256, string calldata, string calldata, string calldata)  external returns (bool);\r\n    function respond4(uint256, string calldata, string calldata, string calldata, string calldata)  external returns (bool);\r\n    function respondBytes32Array(uint256, bytes32[] calldata, string calldata)  external returns (bool);\r\n    function respondIntArray(uint256,int[] calldata)  external returns (bool);\r\n\r\n\r\n    function balanceOf(address who)  public view returns (uint256); \r\n    function transfer(address to, uint256 value)  public returns (bool);\r\n\tfunction approve(address spender, uint256 value)  public returns (bool);\r\n\r\n\r\n}"
    },
    "contracts/token/Faucet.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\n contract Token {\r\n    function transfer(address to, uint256 amount) public  returns (bool);\r\n\r\n    function balanceOf(address addr) public view  returns (uint256);\r\n}\r\n\r\ncontract Faucet {\r\n    Token token;\r\n    address payable public owner;\r\n    uint256 public rate = 1000; // 1 ETH = 1000 ZAP\r\n    event BUYZAP(\r\n        address indexed _buyer,\r\n        uint256 indexed _amount,\r\n        uint256 indexed _rate\r\n    );\r\n\r\n    // 1: 1000 ratio\r\n\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(address _token) public {\r\n        owner = msg.sender;\r\n        token = Token(_token);\r\n    }\r\n\r\n    event Log(uint256 n1, uint256 n2);\r\n\r\n    function buyZap(address to, uint256 amt) public payable {\r\n        require(amt > 0);\r\n        amt = amt * rate;\r\n        require(amt <= token.balanceOf(address(this)));\r\n        token.transfer(to, amt);\r\n        emit BUYZAP(msg.sender, amt, rate);\r\n    }\r\n\r\n    function withdrawTok() public ownerOnly {\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawEther() public ownerOnly {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}\r\n"
    },
    "contracts/token/ZapToken.sol": {
      "content": "pragma solidity =0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n contract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view  returns (uint256);\r\n    function transfer(address to, uint256 value) public  returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\n contract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view  returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public  returns (bool);\r\n    function approve(address spender, uint256 value) public  returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) balances;\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return balance : An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view  returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n    using SafeMath for uint256;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool) {\r\n        require(_to != address(0));\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public  returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return remaining : A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view  returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval (address _spender, uint _addedValue) public\r\n        returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public\r\n        returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n    using SafeMath for uint256;\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n    bool public mintingFinished = false;\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() onlyOwner public returns (bool) {\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ZapToken is MintableToken {\r\n    string public name = \"Zap\";\r\n    string public symbol = \"ZAP\";\r\n    uint256 public decimals = 18;\r\n\r\n    function allocate(address to, uint amount) public{\r\n        mint(to,amount);\r\n    }\r\n}\r\n"
    },
    "contracts/token/ZapTokenBSC.sol": {
      "content": "pragma solidity =0.5.16;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n\n        assert(a == 0 || c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n\n        assert(c >= a);\n\n        return c;\n    }\n}\n\ncontract ERC20Basic {\n    uint256 public totalSupply = 520000000000000000000000000;\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n\n * @title ERC20 interface\n\n * @dev see https://github.com/ethereum/EIPs/issues/20\n\n */\n\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    /**\n\n    * @dev transfer token for a specified address\n\n    * @param _to The address to transfer to.\n\n    * @param _value The amount to be transferred.\n\n    */\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // SafeMath.sub will throw if there is not enough balance.\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param _owner The address to query the the balance of.\n\n    * @return balance : An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\ncontract Ownable {\n    address payable public owner;\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n\n    /// @dev Throws if called by any contract other than latest designated caller\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n    /// @param newOwner The address to transfer ownership to.\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\ncontract StandardToken is ERC20, BasicToken {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) allowed;\n\n    /**\n\n     * @dev Transfer tokens from one address to another\n\n     * @param _from address The address which you want to send tokens from\n\n     * @param _to address The address which you want to transfer to\n\n     * @param _value uint256 the amount of tokens to be transferred\n\n     */\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\n        // require (_value <= _allowance);\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n     *\n\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _value The amount of tokens to be spent.\n\n     */\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n    }\n\n    /**\n\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n     * @param _owner address The address which owns the funds.\n\n     * @param _spender address The address which will spend the funds.\n\n     * @return remaining A uint256 specifying the amount of tokens still available for the spender.\n\n     */\n\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256 remaining)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n\n     * approve should be called when allowed[_spender] == 0. To increment\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     */\n\n    function increaseApproval(address _spender, uint256 _addedValue)\n        public\n        returns (bool success)\n    {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(\n            _addedValue\n        );\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint256 _subtractedValue)\n        public\n        returns (bool success)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n    }\n}\n\ncontract MintableToken is StandardToken, Ownable {\n    using SafeMath for uint256;\n\n    event Mint(address indexed to, uint256 amount);\n\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n\n        _;\n    }\n\n    /**\n\n     * @dev Function to mint tokens\n\n     * @param _to The address that will receive the minted tokens.\n\n     * @param _amount The amount of tokens to mint.\n\n     * @return A boolean that indicates if the operation was successful.\n\n     */\n\n    function mint(address _to, uint256 _amount)\n        public\n        onlyOwner\n        canMint\n        returns (bool)\n    {\n        totalSupply = totalSupply.add(_amount);\n\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Mint(_to, _amount);\n\n        emit Transfer(address(0), _to, _amount);\n\n        return true;\n    }\n\n    /**\n\n     * @dev Function to stop minting new tokens.\n\n     * @return True if the operation was successful.\n\n     */\n\n    function finishMinting() public onlyOwner returns (bool) {\n        mintingFinished = true;\n\n        emit MintFinished();\n\n        return true;\n    }\n}\n\ncontract ZapTokenBSC is MintableToken {\n    string public name = \"ZAP TOKEN\";\n\n    string public symbol = \"ZAP\";\n\n    uint256 public decimals = 18;\n\n    constructor() public {\n        balances[msg.sender] = totalSupply;\n\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function allocate(address to, uint256 amount) public {\n        mint(to, amount);\n    }\n}\n"
    },
    "contracts/zap-miner/Zap.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport './libraries/SafeMathM.sol';\nimport './libraries/ZapStorage.sol';\nimport './libraries/ZapDispute.sol';\nimport './libraries/ZapStake.sol';\nimport './libraries/ZapLibrary.sol';\nimport '../token/ZapTokenBSC.sol';\nimport './libraries/Address.sol';\nimport './Vault.sol';\n\n/**\n * @title Zap Oracle System\n * @dev Oracle contract where miners can submit the proof of work along with the value.\n * The logic for this contract is in ZapLibrary.sol, ZapDispute.sol and ZapStake.sol\n */\ncontract Zap {\n    event NewDispute(\n        uint256 indexed _disputeId,\n        uint256 indexed _requestId,\n        uint256 _timestamp,\n        address _miner\n    ); //emitted when a new dispute is initialized\n    event NewChallenge(\n        bytes32 _currentChallenge,\n        uint256 indexed _currentRequestId,\n        uint256 _difficulty,\n        uint256 _multiplier,\n        string _query,\n        uint256 _totalTips\n    ); //emits when a new challenge is created (either on mined block or when a new request is pushed forward on waiting system)\n    event TipAdded(\n        address indexed _sender,\n        uint256 indexed _requestId,\n        uint256 _tip,\n        uint256 _totalTips\n    );\n    event NewRequestOnDeck(\n        uint256 indexed _requestId,\n        string _query,\n        bytes32 _onDeckQueryHash,\n        uint256 _onDeckTotalTips\n    ); //emits when a the payout of another request is higher after adding to the payoutPool or submitting a request\n    event DataRequested(\n        address indexed _sender,\n        string _query,\n        string _querySymbol,\n        uint256 _granularity,\n        uint256 indexed _requestId,\n        uint256 _totalTips\n    ); //Emits upon someone adding value to a pool; msg.sender, amount added, and timestamp incentivized to be mined\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    ); //ERC20 Approval event\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    using SafeMathM for uint256;\n    using Address for address;\n\n    using ZapDispute for ZapStorage.ZapStorageStruct;\n    using ZapLibrary for ZapStorage.ZapStorageStruct;\n    using ZapStake for ZapStorage.ZapStorageStruct;\n\n    ZapStorage.ZapStorageStruct private zap;\n    ZapTokenBSC public token;\n    // Vault public vault;\n    // address public vaultAddress;\n\n    address payable public owner;\n\n    constructor(address zapTokenBsc) public {\n        token = ZapTokenBSC(zapTokenBsc);\n        owner = msg.sender;\n    }\n\n    /// @dev Throws if called by any contract other than latest designated caller\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function balanceOf(address _user) public view returns (uint256 balance) {\n        return token.balanceOf(_user);\n    }\n\n    /*Functions*/\n\n    /**\n     * @dev Helps initialize a dispute by assigning it a disputeId\n     * when a miner returns a false on the validate array(in Zap.ProofOfWork) it sends the\n     * invalidated value information to POS voting\n     * @param _requestId being disputed\n     * @param _timestamp being disputed\n     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n     * requires 5 miners to submit a value.\n     */\n    function beginDispute(\n        uint256 _requestId,\n        uint256 _timestamp,\n        uint256 _minerIndex\n    ) external {\n        ZapStorage.Request storage _request = zap.requestDetails[_requestId];\n        // FOR BTC:require that no more than a day( (24 hours * 60 minutes)/10minutes=144 blocks) has gone by since the value was \"mined\"\n        // FOR BSC:require that no more than a day( (24 hours * 60 minutes * 60 seconds)/3 seconds=28800 blocks) has gone by since the value was \"mined\"\n        // FOR ETH:require that no more than a day( (24 hours * 60 minutes * 60 seconds)/13 seconds=6646 blocks) has gone by since the value was \"mined\"\n        require(block.number - _request.minedBlockNum[_timestamp] <= 28800, \"Must dispute within 1 day of being mined.\");\n        require(_request.minedBlockNum[_timestamp] > 0);\n        require(_minerIndex < 5);\n        //require that only stakers can dispute values\n        require(zap.stakerDetails[msg.sender].currentStatus == 1, \"Only stakers can begin a dispute\");\n\n        //ensure the msg.sender is staked and not in dispute\n        require(token.balanceOf(msg.sender) > zap.uintVars[keccak256('disputeFee')], \"You do not have a balance to dispute.\");\n        \n\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\n        //provided by the party initiating the dispute\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\n        bytes32 _hash = keccak256(\n            abi.encodePacked(_miner, _requestId, _timestamp)\n        );\n\n        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\n        require(zap.disputeIdByDisputeHash[_hash] == 0);\n\n        transferFrom(msg.sender, zap.addressVars[keccak256('_owner')], zap.uintVars[keccak256('disputeFee')]);\n\n        //Increase the dispute count by 1\n        zap.uintVars[keccak256('disputeCount')] =\n            zap.uintVars[keccak256('disputeCount')] +\n            1;\n\n        //Sets the new disputeCount as the disputeId\n        uint256 disputeId = zap.uintVars[keccak256('disputeCount')];\n\n        //maps the dispute hash to the disputeId\n        zap.disputeIdByDisputeHash[_hash] = disputeId;\n        //maps the dispute to the Dispute struct\n        zap.disputesById[disputeId] = ZapStorage.Dispute({\n            hash: _hash,\n            isPropFork: false,\n            isZM: false,\n            reportedMiner: _miner,\n            reportingParty: msg.sender,\n            proposedForkAddress: address(0),\n            executed: false,\n            disputeVotePassed: false,\n            tally: 0\n        });\n\n        //Saves all the dispute variables for the disputeId\n        zap.disputesById[disputeId].disputeUintVars[\n            keccak256('requestId')\n        ] = _requestId;\n        zap.disputesById[disputeId].disputeUintVars[\n            keccak256('timestamp')\n        ] = _timestamp;\n        zap.disputesById[disputeId].disputeUintVars[\n            keccak256('value')\n        ] = _request.valuesByTimestamp[_timestamp][_minerIndex];\n        zap.disputesById[disputeId].disputeUintVars[\n            keccak256('minExecutionDate')\n        ] = now + 7 days;\n        zap.disputesById[disputeId].disputeUintVars[\n            keccak256('blockNumber')\n        ] = block.number;\n        zap.disputesById[disputeId].disputeUintVars[\n            keccak256('minerSlot')\n        ] = _minerIndex;\n        zap.disputesById[disputeId].disputeUintVars[keccak256('fee')] = zap\n        .uintVars[keccak256('disputeFee')];\n\n        //Values are sorted as they come in and the official value is the median of the first five\n        //So the \"official value\" miner is always minerIndex==2. If the official value is being\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\n        if (_minerIndex == 2) {\n            zap.requestDetails[_requestId].inDispute[_timestamp] = true;\n        }\n        zap.stakerDetails[_miner].currentStatus = 3;\n        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\n    }\n\n    /**\n     * @dev Allows token holders to vote\n     * @param _disputeId is the dispute id\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n     */\n    function vote(uint256 _disputeId, bool _supportsDispute) external {\n\n        address vaultAddress = zap.addressVars[keccak256('_vault')];\n        Vault vault = Vault(vaultAddress);\n\n        uint256 voteWeight = vault.userBalance(msg.sender);\n        zap.vote(_disputeId, _supportsDispute, voteWeight);\n    }\n\n    /**\n     * @dev tallies the votes.\n     * @param _disputeId is the dispute id\n     */\n    function tallyVotes(uint256 _disputeId) external {\n\n        (address _from, address _to, uint256 _disputeFee) = zap.tallyVotes(_disputeId);\n\n        ZapStorage.Dispute storage disp = zap.disputesById[_disputeId];\n        bytes memory data;\n\n        if (!disp.isPropFork) {\n            // If this is a normal dispute, send the winners amount to their wallet\n            data = abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                _to, _disputeFee);\n            _callOptionalReturn(token, data);\n\n        }\n\n        if (disp.isZM) {\n            // If this is fork proposal for changing ZapMaster, transfer the zapMaster\n            // total balance of current ZapMaster\n            uint256 zapBalance = token.balanceOf(address(this));\n\n            data = abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                disp.proposedForkAddress, zapBalance);\n            // transfer `zapBalance` ZAP from current ZapMaster to new ZapMaster\n            _callOptionalReturn(token, data);\n        }\n    }\n\n    /**\n     * @dev Allows for a fork to be proposed\n     * @param _propNewZapAddress address for new proposed Zap\n     */\n    function proposeFork(address _propNewZapAddress, bool isZM) external {\n        zap.proposeFork(_propNewZapAddress, isZM);\n            transferFrom(\n                msg.sender,\n                zap.addressVars[keccak256(\"_owner\")],\n                zap.uintVars[keccak256('disputeFee')]\n            );\n    }\n\n    /**\n     * @dev Request to retreive value from oracle based on timestamp. The tip is not required to be\n     * greater than 0 because there are no tokens in circulation for the initial(genesis) request\n     * @param _c_sapi string API being requested be mined\n     * @param _c_symbol is the zshort string symbol for the api request\n     * @param _granularity is the number of decimals miners should include on the submitted value\n     * @param _tip amount the requester is willing to pay to be get on queue. Miners\n     * mine the onDeckQueryHash, or the api with the highest payout pool\n     */\n    function requestData(\n        string calldata _c_sapi,\n        string calldata _c_symbol,\n        uint256 _granularity,\n        uint256 _tip\n    ) external {\n        //Require at least one decimal place\n        require(_granularity > 0);\n\n        //But no more than 18 decimal places\n        require(_granularity <= 1e18);\n\n        //If it has been requested before then add the tip to it otherwise create the queryHash for it\n        string memory _sapi = _c_sapi;\n        string memory _symbol = _c_symbol;\n        require(bytes(_sapi).length > 0);\n        require(bytes(_symbol).length < 64);\n        bytes32 _queryHash = keccak256(abi.encodePacked(_sapi, _granularity));\n\n        //If this is the first time the API and granularity combination has been requested then create the API and granularity hash\n        //otherwise the tip will be added to the requestId submitted\n        if (zap.requestIdByQueryHash[_queryHash] == 0) {\n            zap.uintVars[keccak256('requestCount')]++;\n            uint256 _requestId = zap.uintVars[keccak256('requestCount')];\n            zap.requestDetails[_requestId] = ZapStorage.Request({\n                queryString: _sapi,\n                dataSymbol: _symbol,\n                queryHash: _queryHash,\n                requestTimestamps: new uint256[](0)\n            });\n            zap.requestDetails[_requestId].apiUintVars[\n                keccak256('granularity')\n            ] = _granularity;\n            zap.requestDetails[_requestId].apiUintVars[\n                keccak256('requestQPosition')\n            ] = 0;\n            zap.requestDetails[_requestId].apiUintVars[\n                keccak256('totalTip')\n            ] = 0;\n            zap.requestIdByQueryHash[_queryHash] = _requestId;\n\n            //If the tip > 0 it tranfers the tip to this contract\n            if (_tip > 0) {\n                transferFrom(msg.sender, address(this), _tip);\n            }\n            updateOnDeck(_requestId, _tip);\n            emit DataRequested(\n                msg.sender,\n                zap.requestDetails[_requestId].queryString,\n                zap.requestDetails[_requestId].dataSymbol,\n                _granularity,\n                _requestId,\n                _tip\n            );\n        }\n        //Add tip to existing request id since this is not the first time the api and granularity have been requested\n        else {\n            addTip(zap.requestIdByQueryHash[_queryHash], _tip);\n        }\n    }\n\n    /**\n     * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\n     * @param _nonce uint submitted by miner\n     * @param _requestId the apiId being mined\n     * @param _value of api query\n     */\n    function submitMiningSolution(\n        string calldata _nonce,\n        uint256 _requestId,\n        uint256 _value\n    ) external {\n        zap.submitMiningSolution(_nonce, _requestId, _value);\n\n        ZapStorage.Details[5] memory a = zap.currentMiners;\n\n        address vaultAddress = zap.addressVars[keccak256('_vault')];\n        Vault vault = Vault(vaultAddress);\n\n        uint256 minerReward = zap.uintVars[keccak256('currentMinerReward')];\n\n        if (minerReward != 0){\n            // Pay the miners\n            for (uint256 i = 0; i < 5; i++) {\n                if (a[i].miner != address(0)){\n                    transfer(address(vault), minerReward);\n                    vault.deposit(a[i].miner, minerReward);\n                }\n            }\n\n            // Pay the devshare\n            transfer(\n                zap.addressVars[keccak256('_owner')],\n                zap.uintVars[keccak256('devShare')]\n            );\n        }\n\n        zap.uintVars[keccak256('currentMinerReward')] = 0;\n    }\n\n    /**\n     * @dev This function allows miners to deposit their stake.\n     */\n    function depositStake() external {\n        // require balance is >= here before it hits NewStake()\n        uint256 stakeAmount = zap.uintVars[keccak256('stakeAmount')];\n        require(\n            token.balanceOf(msg.sender) >=\n                stakeAmount,\n            \"Not enough ZAP to stake\"\n        );\n        zap.depositStake();\n\n        address vaultAddress = zap.addressVars[keccak256('_vault')];\n        Vault vault = Vault(vaultAddress);\n\n        token.approve(address(this), stakeAmount);\n        transferFrom(msg.sender, vaultAddress, stakeAmount);\n        vault.deposit(msg.sender, stakeAmount);\n\n    }\n\n    /**\n     * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n     * can withdraw the stake\n     */\n    function requestStakingWithdraw() external {\n        zap.requestStakingWithdraw();\n    }\n\n    /**\n     * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\n     */\n    function withdrawStake() external {\n        zap.withdrawStake();\n\n        address vaultAddress = zap.addressVars[keccak256('_vault')];\n        Vault vault = Vault(vaultAddress);\n\n        uint256 userBalance = vault.userBalance(msg.sender);\n\n        transferFrom(address(vault), msg.sender, userBalance);\n\n        vault.withdraw(msg.sender, userBalance);\n    }\n\n    /**\n     * @dev This function approves a _spender an _amount of tokens to use\n     * @param _spender address\n     * @param _amount amount the spender is being approved for\n     * @return true if spender appproved successfully\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        return token.approve(_spender, _amount);\n    }\n\n    /**\n     * @dev Allows for a transfer of tokens to _to\n     * @param _to The address to send tokens to\n     * @param _amount The amount of tokens to send\n     * @return true if transfer is successful\n     */\n    function transfer(address _to, uint256 _amount) public {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, _to, _amount));\n    }\n\n    /**\n     * @notice Send _amount tokens to _to from _from on the condition it\n     * is approved by _from\n     * @param _from The address holding the tokens being transferred\n     * @param _to The address of the recipient\n     * @param _amount The amount of tokens to be transferred\n     * @return True if the transfer was successful\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, _from, _to, _amount));\n    }\n\n    /**\n     * @dev Getter for the current variables that include the 5 requests Id's\n     * @return the challenge, 5 requestsId, difficulty and tip\n     */\n    function getNewCurrentVariables()\n        external\n        view\n        returns (\n            bytes32 _challenge,\n            uint256[5] memory _requestIds,\n            uint256 _difficutly,\n            uint256 _tip\n        )\n    {\n        return zap.getNewCurrentVariables();\n    }\n\n    /**\n        Migrated from ZapLibrary\n     */\n    /**\n     * @dev Add tip to Request value from oracle\n     * @param _requestId being requested to be mined\n     * @param _tip amount the requester is willing to pay to be get on queue. Miners\n     * mine the onDeckQueryHash, or the api with the highest payout pool\n     */\n    function addTip(uint256 _requestId, uint256 _tip) public {\n        require(_requestId > 0);\n        require(_tip <= 10000 * 1e18, \"Tip cannot be greater than 1000 Zap Tokens.\");\n\n        //If the tip > 0 transfer the tip to this contract\n        if (_tip > 0) {\n            // doTransfer(msg.sender, address(this), _tip);\n            transferFrom(msg.sender, address(this), _tip);\n        }\n\n        //Update the information for the request that should be mined next based on the tip submitted\n        updateOnDeck(_requestId, _tip);\n        emit TipAdded(\n            msg.sender,\n            _requestId,\n            _tip,\n            zap.requestDetails[_requestId].apiUintVars[keccak256('totalTip')]\n        );\n    }\n\n    /**\n     * @dev This function updates APIonQ and the requestQ when requestData or addTip are ran\n     * @param _requestId being requested\n     * @param _tip is the tip to add\n     */\n    function updateOnDeck(uint256 _requestId, uint256 _tip) internal {\n        ZapStorage.Request storage _request = zap.requestDetails[_requestId];\n        uint256 onDeckRequestId = ZapGettersLibrary.getTopRequestID(zap);\n        //If the tip >0 update the tip for the requestId\n        if (_tip > 0) {\n            _request.apiUintVars[keccak256('totalTip')] = _request\n            .apiUintVars[keccak256('totalTip')]\n            .add(_tip);\n        }\n        //Set _payout for the submitted request\n        uint256 _payout = _request.apiUintVars[keccak256('totalTip')];\n\n        //If there is no current request being mined\n        //then set the currentRequestId to the requestid of the requestData or addtip requestId submitted,\n        // the totalTips to the payout/tip submitted, and issue a new mining challenge\n        if (zap.uintVars[keccak256('currentRequestId')] == 0) {\n            _request.apiUintVars[keccak256('totalTip')] = 0;\n            zap.uintVars[keccak256('currentRequestId')] = _requestId;\n            zap.uintVars[keccak256('currentTotalTips')] = _payout;\n            zap.currentChallenge = keccak256(\n                abi.encodePacked(\n                    _payout,\n                    zap.currentChallenge,\n                    blockhash(block.number - 1)\n                )\n            ); // Save hash for next proof\n            emit NewChallenge(\n                zap.currentChallenge,\n                zap.uintVars[keccak256('currentRequestId')],\n                zap.uintVars[keccak256('difficulty')],\n                zap\n                    .requestDetails[zap.uintVars[keccak256('currentRequestId')]]\n                    .apiUintVars[keccak256('granularity')],\n                zap\n                    .requestDetails[zap.uintVars[keccak256('currentRequestId')]]\n                    .queryString,\n                zap.uintVars[keccak256('currentTotalTips')]\n            );\n        } else {\n            //If there is no OnDeckRequestId\n            //then replace/add the requestId to be the OnDeckRequestId, queryHash and OnDeckTotalTips(current highest payout, aside from what\n            //is being currently mined)\n            if (\n                _payout >\n                zap.requestDetails[onDeckRequestId].apiUintVars[\n                    keccak256('totalTip')\n                ] ||\n                (onDeckRequestId == 0)\n            ) {\n                //let everyone know the next on queue has been replaced\n                emit NewRequestOnDeck(\n                    _requestId,\n                    _request.queryString,\n                    _request.queryHash,\n                    _payout\n                );\n            }\n\n            //if the request is not part of the requestQ[51] array\n            //then add to the requestQ[51] only if the _payout/tip is greater than the minimum(tip) in the requestQ[51] array\n            if (_request.apiUintVars[keccak256('requestQPosition')] == 0) {\n                uint256 _min;\n                uint256 _index;\n                (_min, _index) = Utilities.getMin(zap.requestQ);\n                //we have to zero out the oldOne\n                //if the _payout is greater than the current minimum payout in the requestQ[51] or if the minimum is zero\n                //then add it to the requestQ array aand map its index information to the requestId and the apiUintvars\n                if (_payout > _min || _min == 0) {\n                    zap.requestQ[_index] = _payout;\n                    zap\n                    .requestDetails[zap.requestIdByRequestQIndex[_index]]\n                    .apiUintVars[keccak256('requestQPosition')] = 0;\n                    zap.requestIdByRequestQIndex[_index] = _requestId;\n                    _request.apiUintVars[\n                        keccak256('requestQPosition')\n                    ] = _index;\n                }\n            }\n            //else if the requestid is part of the requestQ[51] then update the tip for it\n            else if (_tip > 0) {\n                zap.requestQ[\n                    _request.apiUintVars[keccak256('requestQPosition')]\n                ] += _tip;\n            }\n        }\n    }\n\n    /**\n     * Increase the approval of ZapMaster for the Vault\n     */\n    function increaseVaultApproval(address vaultAddress) public returns (bool) {\n        Vault vault = Vault(vaultAddress);\n        return vault.increaseApproval();\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param _token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(ZapTokenBSC _token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(_token).functionCall(data, \"ZapTokenBSC: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"ZapTokenBSC: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/SafeMathM.sol": {
      "content": "pragma solidity =0.5.16;\n\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\nlibrary SafeMathM {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function max(int256 a, int256 b) internal pure returns (uint256) {\n        assert(a >= 0 && b >= 0);\n        return a > b ? uint256(a) : uint256(b);\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/ZapStorage.sol": {
      "content": "pragma solidity ^0.5.1;\n\n/**\n * @title Zap Oracle Storage Library\n * @dev Contains all the variables/structs used by Zap\n */\n\n// Libraries contain reusable Solidity types\nlibrary ZapStorage {\n    //Internal struct for use in proof-of-work submission\n    struct Details {\n        uint256 value;\n        address miner;\n    }\n\n    struct Dispute {\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\n        int256 tally; //current tally of votes for - against measure\n        bool executed; //is the dispute settled\n        bool disputeVotePassed; //did the vote pass?\n        bool isPropFork; //true for fork proposal NEW\n        bool isZM; //true if proposed fork is to change Zap Master\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\n        address proposedForkAddress; //new fork address (if fork proposal)\n        mapping(bytes32 => uint256) disputeUintVars;\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\n        //e.g. ZapStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\"requestId\")]\n        //These are the variables saved in this mapping:\n        // uint keccak256(\"requestId\");//apiID of disputed value\n        // uint keccak256(\"timestamp\");//timestamp of distputed value\n        // uint keccak256(\"value\"); //the value being disputed\n        // uint keccak256(\"minExecutionDate\");//7 days from when dispute initialized\n        // uint keccak256(\"numberOfVotes\");//the number of parties who have voted on the measure\n        // uint keccak256(\"blockNumber\");// the blocknumber for which votes will be calculated from\n        // uint keccak256(\"minerSlot\"); //index in dispute array\n        // uint keccak256(\"quorum\"); //quorum for dispute vote NEW\n        // uint keccak256(\"fee\"); //fee paid corresponding to dispute\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\n    }\n\n    struct StakeInfo {\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute\n        uint256 startDate; //stake start date\n    }\n\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\n    struct Checkpoint {\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\n        uint128 value; // value is the amount of tokens at a specific block number\n    }\n\n    struct Request {\n        string queryString; //id to string api\n        string dataSymbol; //short name for api request\n        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\n        mapping(bytes32 => uint256) apiUintVars;\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]\n        //These are the variables saved in this mapping:\n        // uint keccak256(\"granularity\"); //multiplier for miners\n        // uint keccak256(\"requestQPosition\"); //index in requestQ\n        // uint keccak256(\"totalTip\");//bonus portion of payout\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\n        mapping(uint256 => uint256) finalValues; //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\n        mapping(uint256 => address[5]) minersByValue;\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\n    }\n\n    struct ZapStorageStruct {\n        bytes32 currentChallenge; //current challenge to be solved\n        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\n        uint256[] newValueTimestamps; //array of all timestamps requested\n        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\n        mapping(bytes32 => address) addressVars;\n        //Address fields in the Zap contract are saved the addressVars mapping\n        //e.g. addressVars[keccak256(\"zapContract\")] = address\n        //These are the variables saved in this mapping:\n        // address keccak256(\"zapContract\");//Zap address\n        // address  keccak256(\"zapTokenContract\");//ZapToken address\n        // address  keccak256(\"_owner\");//Zap Owner address\n        // address  keccak256(\"_deity\");//Zap Owner that can do things at will\n        // address  keccak256(\"_vault\");//Address of the vault contract set in Zap.sol\n        mapping(bytes32 => uint256) uintVars;\n        //uint fields in the Zap contract are saved the uintVars mapping\n        //e.g. uintVars[keccak256(\"decimals\")] = uint\n        //These are the variables saved in this mapping:\n        // keccak256(\"decimals\");    //18 decimal standard ERC20\n        // keccak256(\"disputeFee\");//cost to dispute a mined value\n        // keccak256(\"disputeCount\");//totalHistoricalDisputes\n        // keccak256(\"total_supply\"); //total_supply of the token in circulation\n        // keccak256(\"stakeAmount\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\n        // keccak256(\"stakerCount\"); //number of parties currently staked\n        // keccak256(\"timeOfLastNewValue\"); // time of last challenge solved\n        // keccak256(\"difficulty\"); // Difficulty of current block\n        // keccak256(\"currentTotalTips\"); //value of highest api/timestamp PayoutPool\n        // keccak256(\"currentRequestId\"); //API being mined--updates with the ApiOnQ Id\n        // keccak256(\"requestCount\"); // total number of requests through the system\n        // keccak256(\"slotProgress\");//Number of miners who have mined this value so far\n        // keccak256(\"miningReward\");//Mining Reward in PoWo tokens given to all miners per value\n        // keccak256(\"timeTarget\"); //The time between blocks (mined Oracle values)\n        // keccak256(\"currentMinerReward\"); //The last reward given to miners on creation of a new block\n        mapping(bytes32 => mapping(address => bool)) minersByChallenge; //This is a boolean that tells you if a given challenge has been completed by a given miner\n        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\n        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\n        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\n        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\n        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\n        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\n        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\n        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\n        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/ZapDispute.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport './SafeMathM.sol';\nimport './ZapStorage.sol';\n\n/**\n * @title Zap Dispute\n * @dev Contais the methods related to disputes. Zap.sol references this library for function's logic.\n */\n\nlibrary ZapDispute {\n    using SafeMathM for uint256;\n\n    event NewDispute(\n        uint256 indexed _disputeId,\n        uint256 indexed _requestId,\n        uint256 _timestamp,\n        address _miner\n    ); //emitted when a new dispute is initialized\n    event Voted(\n        uint256 indexed _disputeID,\n        bool _position,\n        address indexed _voter\n    ); //emitted when a new vote happens\n    event DisputeVoteTallied(\n        uint256 indexed _disputeID,\n        int256 _result,\n        address indexed _reportedMiner,\n        address _reportingParty,\n        bool _active\n    ); //emitted upon dispute tally\n    event NewZapAddress(address _newZap); //emmited when a proposed fork is voted true\n\n    /*Functions*/\n\n    /**\n     * @dev Allows token holders to vote\n     * @param _disputeId is the dispute id\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n     */\n    function vote(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _disputeId,\n        bool _supportsDispute,\n        uint256 voteWeight\n    ) public {\n        ZapStorage.Dispute storage disp = self.disputesById[_disputeId];\n\n        //ensure that only stakers can vote\n        require(self.stakerDetails[msg.sender].currentStatus == 1, \"Only Stakers that are not under dispute can vote\");\n\n        //Require that the msg.sender has not voted\n        require(disp.voted[msg.sender] != true, \"msg.sender has already voted\");\n\n        //Requre that the user had a balance >0 at time/blockNumber the disupte began\n        require(voteWeight > 0, \"User must have a balance greater than zero\");\n\n        //Ensure the reporting party cannot vote for that specific dispute\n        require(msg.sender != disp.reportingParty, \"The reporting party of the dispute cannot vote\");\n\n        //Update user voting status to true\n        disp.voted[msg.sender] = true;\n\n        //Update the number of votes for the dispute\n        disp.disputeUintVars[keccak256('numberOfVotes')] += 1;\n\n        //Update the quorum by adding the voteWeight\n        disp.disputeUintVars[keccak256('quorum')] += voteWeight;\n\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\n        //otherwise decrease it\n        if (_supportsDispute) {\n            disp.tally = disp.tally + int256(voteWeight);\n        } else {\n            disp.tally = disp.tally - int256(voteWeight);\n        }\n\n        //Let the network know the user has voted on the dispute and their casted vote\n        emit Voted(_disputeId, _supportsDispute, msg.sender);\n    }\n\n    /**\n     * @dev tallies the votes.\n     * @param _disputeId is the dispute id\n     */\n    function tallyVotes(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _disputeId\n    ) public returns (address _from, address _to, uint _disputeFee) {\n\n        ZapStorage.Dispute storage disp = self.disputesById[_disputeId];\n        ZapStorage.Request storage _request = self.requestDetails[\n            disp.disputeUintVars[keccak256('requestId')]\n        ];\n        \n        uint disputeFeeForDisputeId = disp.disputeUintVars[keccak256(\"fee\")];\n        address disputeFeeWinnerAddress;\n        \n        //Ensure this has not already been executed/tallied\n        require(!disp.executed, \"This has already been executed\");\n\n        //Ensure the time for voting has elapsed\n        require(now > disp.disputeUintVars[keccak256('minExecutionDate')], \"Cannot vote at this time.\");\n\n        //If the vote is not a proposed fork\n        if (!disp.isPropFork) {\n            ZapStorage.StakeInfo storage stakes = self.stakerDetails[\n                disp.reportedMiner\n            ];\n            // instead of percentage, find the multiple of this dispute voters compared to numbe rof staked users\n            uint quorum = (self.uintVars[keccak256(\"stakerCount\")] - 2) / disp.disputeUintVars[keccak256('numberOfVotes')];\n            //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported\n            // miner and transfer the stakeAmount and dispute fee to the reporting party\n            // the 2nd conditional will check if the amount of voters for this dispute is gte 10% of staked users\n            if (disp.tally > 0 && quorum <= 10) {\n                //Changing the currentStatus and startDate unstakes the reported miner and allows for the\n                //transfer of the stakeAmount\n                stakes.currentStatus = 0;\n                stakes.startDate = now - (now % 86400);\n\n                //Decreases the stakerCount since the miner's stake is being slashed\n                self.uintVars[keccak256('stakerCount')]--;\n                updateDisputeFee(self);\n                \n                //Set the dispute state to passed/true\n                disp.disputeVotePassed = true;\n\n                //If the dispute was succeful(miner found guilty) then update the timestamp value to zero\n                //so that users don't use this datapoint\n                if (\n                    _request.inDispute[\n                        disp.disputeUintVars[keccak256('timestamp')]\n                    ]\n                ) {\n                    _request.finalValues[\n                        disp.disputeUintVars[keccak256('timestamp')]\n                    ] = 0;\n                }\n                \n\n                disputeFeeWinnerAddress = disp.reportingParty;\n\n                // return (address(this), disp.reportingParty, disputeFeeForDisputeId);\n\n                //If the vote for disputing a value is unsuccesful then update the miner status from being on\n                //dispute(currentStatus=3) to staked(currentStatus =1) and tranfer the dispute fee to the miner\n            } else {\n                //Update the miner's current status to staked(currentStatus = 1)\n                stakes.currentStatus = 1;\n\n                if (\n                    _request.inDispute[\n                        disp.disputeUintVars[keccak256('timestamp')]\n                    ]\n                ) {\n                    _request.inDispute[\n                        disp.disputeUintVars[keccak256('timestamp')]\n                    ] = false;\n                }\n                \n                disputeFeeWinnerAddress = disp.reportedMiner;\n\n                // return (address(this), disp.reportedMiner, disputeFeeForDisputeId);\n\n            }\n            //If the vote is for a proposed fork require 35% quorum before executing the update to the new zap contract address\n        } else {\n            if (disp.tally > 0) {\n                require(\n                    disp.disputeUintVars[keccak256('quorum')] >\n                        ((self.uintVars[keccak256('total_supply')] * 35) / 100)\n                );\n                if (!disp.isZM) {\n                    self.addressVars[keccak256('zapContract')] = disp.proposedForkAddress;\n                }\n                disp.disputeVotePassed = true;\n                emit NewZapAddress(disp.proposedForkAddress);\n            }\n        }\n\n        //update the dispute status to executed\n        disp.executed = true;\n        emit DisputeVoteTallied(\n            _disputeId,\n            disp.tally,\n            disp.reportedMiner,\n            disp.reportingParty,\n            disp.disputeVotePassed\n        );\n        return (address(this), disputeFeeWinnerAddress, disputeFeeForDisputeId);\n    }\n\n    /**\n     * @dev Allows for a fork to be proposed\n     * @param _propNewZapAddress address for new proposed Zap\n     */\n    function proposeFork(\n        ZapStorage.ZapStorageStruct storage self,\n        address _propNewZapAddress,\n        bool zm\n    ) public {\n        bytes32 _hash = keccak256(abi.encodePacked(_propNewZapAddress));\n        require(self.disputeIdByDisputeHash[_hash] == 0,\"Dispute Hash is not equal to zero\");\n\n        self.uintVars[keccak256('disputeCount')]++;\n        uint256 disputeId = self.uintVars[keccak256('disputeCount')];\n        self.disputeIdByDisputeHash[_hash] = disputeId;\n        self.disputesById[disputeId] = ZapStorage.Dispute({\n            hash: _hash,\n            isPropFork: true,\n            isZM: zm,\n            reportedMiner: msg.sender,\n            reportingParty: msg.sender,\n            proposedForkAddress: _propNewZapAddress,\n            executed: false,\n            disputeVotePassed: false,\n            tally: 0\n        });\n        self.disputesById[disputeId].disputeUintVars[\n            keccak256('blockNumber')\n        ] = block.number;\n        self.disputesById[disputeId].disputeUintVars[keccak256('fee')] = self\n        .uintVars[keccak256('disputeFee')];\n        self.disputesById[disputeId].disputeUintVars[\n            keccak256('minExecutionDate')\n        ] = now + 7 days;\n    }\n\n    /**\n     * @dev this function allows the dispute fee to fluctuate based on the number of miners on the system.\n     * The floor for the fee is 15.\n     */\n    function updateDisputeFee(ZapStorage.ZapStorageStruct storage self) public {\n        //if the number of staked miners divided by the target count of staked miners is less than 1\n        if (\n            (self.uintVars[keccak256('stakerCount')] * 1000) /\n                self.uintVars[keccak256('targetMiners')] <\n            1000\n        ) {\n            //Set the dispute fee at stakeAmt * (1- stakerCount/targetMiners)\n            //or at the its minimum of 15\n            self.uintVars[keccak256('disputeFee')] = SafeMathM.max(\n                15,\n                self.uintVars[keccak256('stakeAmount')].mul(\n                    1000 -\n                        (self.uintVars[keccak256('stakerCount')] * 1000) /\n                        self.uintVars[keccak256('targetMiners')]\n                ) / 1000\n            );\n        } else {\n            //otherwise set the dispute fee at 15 (the floor/minimum fee allowed)\n            self.uintVars[keccak256('disputeFee')] = 15;\n        }\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/ZapStake.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport \"./ZapStorage.sol\";\nimport \"./ZapDispute.sol\";\n// import \"hardhat/console.sol\";\n\n/**\n* @title Zap Dispute\n* @dev Contais the methods related to miners staking and unstaking. Zap.sol \n* references this library for function's logic.\n*/\n\nlibrary ZapStake {\n    event NewStake(address indexed _sender);//Emits upon new staker\n    event StakeWithdrawn(address indexed _sender);//Emits when a staker is now no longer staked\n    event StakeWithdrawRequested(address indexed _sender);//Emits when a staker begins the 7 day withdraw period\n\n    /*Functions*/\n    \n    /**\n    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\n    * This function is called by the constructor function on ZapMaster.sol\n    */\n    function init(ZapStorage.ZapStorageStruct storage self) public{\n        require(self.uintVars[keccak256(\"decimals\")] == 0, \"Already initialized\");\n        \n        //set Constants\n        self.uintVars[keccak256(\"decimals\")] = 18;\n        self.uintVars[keccak256(\"targetMiners\")] = 200;\n        self.uintVars[keccak256(\"stakeAmount\")] = 500000 * 1e18;\n        self.uintVars[keccak256(\"disputeFee\")] = 970 * 1e18;\n        self.uintVars[keccak256(\"timeTarget\")]= 600;\n        self.uintVars[keccak256(\"timeOfLastNewValue\")] = now - now  % self.uintVars[keccak256(\"timeTarget\")];\n        self.uintVars[keccak256(\"difficulty\")] = 1;\n    }\n\n\n    /**\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n    * can withdraw the deposit\n    */\n    function requestStakingWithdraw(ZapStorage.ZapStorageStruct storage self) public {\n        ZapStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\n        //Require that the miner is staked\n        require(stakes.currentStatus == 1, \"Miner is not staked\");\n\n        //Change the miner staked to locked to be withdrawStake\n        stakes.currentStatus = 2;\n\n        //Change the startDate to now since the lock up period begins now\n        //and the miner can only withdraw 7 days later from now(check the withdraw function)\n        stakes.startDate = now -(now % 86400);\n\n        //Reduce the staker count\n        self.uintVars[keccak256(\"stakerCount\")] -= 1;\n        ZapDispute.updateDisputeFee(self);\n        emit StakeWithdrawRequested(msg.sender);\n    }\n\n    /**\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request \n    */\n    function withdrawStake(ZapStorage.ZapStorageStruct storage self) public {\n        ZapStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have \n        //passed by since they locked for withdraw\n        require(now - (now % 86400) - stakes.startDate >= 7 days, \"Can't withdraw yet. Need to wait at LEAST 7 days from stake start date.\");\n        require(stakes.currentStatus == 2, \"Required to request withdraw of stake\");\n        stakes.currentStatus = 0;\n\n        emit StakeWithdrawn(msg.sender);\n    }\n\n    /**\n    * @dev This function allows miners to deposit their stake.\n    */\n    function depositStake(ZapStorage.ZapStorageStruct storage self) public {\n      newStake(self, msg.sender);\n      //self adjusting disputeFee\n      ZapDispute.updateDisputeFee(self);\n    }\n\n    /**\n    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\n    * The function updates their status/state and status start date so they are locked it so they can't withdraw\n    * and updates the number of stakers in the system.\n    */\n    function newStake(ZapStorage.ZapStorageStruct storage self, address staker) internal {\n\n        //Ensure they can only stake if they are not currrently staked \n        require(self.stakerDetails[staker].currentStatus == 0, \"ZapStake: Staker is already staked\");\n        self.uintVars[keccak256(\"stakerCount\")] += 1;\n        self.stakerDetails[staker] = ZapStorage.StakeInfo({\n            currentStatus: 1,\n            //this resets their stake start date to today\n            startDate: now - (now % 86400)\n        });\n\n        emit NewStake(staker);\n    }\n\n     /**\n    * @dev Getter function for the requestId being mined \n    * @return variables for the current minin event: Challenge, 5 RequestId, difficulty and Totaltips\n    */\n    function getNewCurrentVariables(ZapStorage.ZapStorageStruct storage self) internal view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficulty, uint256 _tip){\n        for(uint i=0;i<5;i++){\n            _requestIds[i] =  self.currentMiners[i].value;\n        }\n        return (self.currentChallenge,_requestIds,self.uintVars[keccak256(\"difficulty\")],self.uintVars[keccak256(\"currentTotalTips\")]);\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/ZapLibrary.sol": {
      "content": "// pragma solidity =0.5.16;\npragma solidity =0.5.16;\n\nimport './SafeMathM.sol';\nimport './SignedSafeMath.sol';\nimport './Utilities.sol';\nimport './ZapStorage.sol';\nimport './ZapDispute.sol';\nimport './ZapStake.sol';\nimport './ZapGettersLibrary.sol';\n\n\n/**\n * @title Zap Oracle System Library\n * @dev Contains the functions' logic for the Zap contract where miners can submit the proof of work\n * along with the value and smart contracts can requestData and tip miners.\n */\nlibrary ZapLibrary {\n    using SafeMathM for uint256;\n    using SignedSafeMath for int256;\n\n    event TipAdded(\n        address indexed _sender,\n        uint256 indexed _requestId,\n        uint256 _tip,\n        uint256 _totalTips\n    );\n    event DataRequested(\n        address indexed _sender,\n        string _query,\n        string _querySymbol,\n        uint256 _granularity,\n        uint256 indexed _requestId,\n        uint256 _totalTips\n    ); //Emits upon someone adding value to a pool; msg.sender, amount added, and timestamp incentivized to be mined\n    event NewChallenge(\n        bytes32 _currentChallenge,\n        uint256 indexed _currentRequestId,\n        uint256 _difficulty,\n        uint256 _multiplier,\n        string _query,\n        uint256 _totalTips\n    ); //emits when a new challenge is created (either on mined block or when a new request is pushed forward on waiting system)\n    event NewRequestOnDeck(\n        uint256 indexed _requestId,\n        string _query,\n        bytes32 _onDeckQueryHash,\n        uint256 _onDeckTotalTips\n    ); //emits when a the payout of another request is higher after adding to the payoutPool or submitting a request\n    event NewValue(\n        uint256 indexed _requestId,\n        uint256 _time,\n        uint256 _value,\n        uint256 _totalTips,\n        bytes32 _currentChallenge\n    ); //Emits upon a successful Mine, indicates the blocktime at point of the mine and the value mined\n    event NonceSubmitted(\n        address indexed _miner,\n        string _nonce,\n        uint256 indexed _requestId,\n        uint256 _value,\n        bytes32 _currentChallenge\n    ); //Emits upon each mine (5 total) and shows the miner, nonce, and value submitted\n    event OwnershipTransferred(\n        address indexed _previousOwner,\n        address indexed _newOwner\n    );\n\n    /*Functions*/\n\n    /**\n     * @dev This fucntion is called by submitMiningSolution and adjusts the difficulty, sorts and stores the first\n     * 5 values received, pays the miners, the dev share and assigns a new challenge\n     * @param _nonce or solution for the PoW  for the requestId\n     * @param _requestId for the current request being mined\n     */\n    function newBlock(\n        ZapStorage.ZapStorageStruct storage self,\n        string memory _nonce,\n        uint256 _requestId\n    ) internal {\n        ZapStorage.Request storage _request = self.requestDetails[_requestId];\n\n        // If the difference between the timeTarget and how long it takes to solve the challenge this updates the challenge\n        //difficulty up or donw by the difference between the target time and how long it took to solve the prevous challenge\n        //otherwise it sets it to 1\n\n        // difficulty + difficulty(timeTarget - (now - timeOfLastNewValue))\n\n        int256 _newDiff = int256(self.uintVars[keccak256('difficulty')])\n            .add(\n                int256(self.uintVars[keccak256('difficulty')]).mul(\n                    int256(self.uintVars[keccak256('timeTarget')]).sub(\n                        int256(\n                            now.sub(\n                                self.uintVars[keccak256('timeOfLastNewValue')]\n                            )\n                        )\n                    )\n                )\n            )\n            .div(100);\n\n        // original\n        // int256 _newDiff = int256(self.uintVars[keccak256('difficulty')]) +\n        //     (int256(self.uintVars[keccak256('difficulty')]) *\n        //         (int256(self.uintVars[keccak256('timeTarget')]) -\n        //             int256(\n        //                 now - self.uintVars[keccak256('timeOfLastNewValue')]\n        //             ))) /\n        //     100;\n\n        if (_newDiff <= 0) {\n            self.uintVars[keccak256('difficulty')] = 1;\n        } else {\n            self.uintVars[keccak256('difficulty')] = uint256(_newDiff);\n        }\n\n        //Sets time of value submission rounded to 1 minute\n        self.uintVars[keccak256('timeOfLastNewValue')] =\n            now -\n            (now % 1 minutes);\n\n        //The sorting algorithm that sorts the values of the first five values that come in\n        ZapStorage.Details[5] memory a = self.currentMiners;\n        uint256 i;\n        for (i = 1; i < 5; i++) {\n            uint256 temp = a[i].value;\n            address temp2 = a[i].miner;\n            uint256 j = i;\n            while (j > 0 && temp < a[j - 1].value) {\n                a[j].value = a[j - 1].value;\n                a[j].miner = a[j - 1].miner;\n                j--;\n            }\n            if (j < i) {\n                a[j].value = temp;\n                a[j].miner = temp2;\n            }\n        }\n\n        //Pay the miners\n        // default reward is 6 Zap tokens\n        if (self.uintVars[keccak256('currentReward')] == 0) {\n            self.uintVars[keccak256('currentReward')] = 6e18;\n        }\n        if (self.uintVars[keccak256('currentReward')] > 1e18) {\n        // adjust payout = payout * ratio 0.000030612633181126/1e18  \n            self.uintVars[keccak256('currentReward')] =\n                self.uintVars[keccak256('currentReward')] -\n                (self.uintVars[keccak256('currentReward')] * 30612633181126) /\n                1e18;\n            // dev share is 50% of current reward\n            self.uintVars[keccak256('devShare')] =\n                ((self.uintVars[keccak256('currentReward')]) * 50) /\n                100;\n        } else {\n            self.uintVars[keccak256('currentReward')] = 1e18;\n        }\n\n        uint256 baseReward = (self.uintVars[keccak256('currentReward')] /\n            1e18) * 1e18;\n        self.uintVars[keccak256('currentMinerReward')] =\n            baseReward +\n            self.uintVars[keccak256('currentTotalTips')] /\n            5;\n\n        emit NewValue(\n            _requestId,\n            self.uintVars[keccak256('timeOfLastNewValue')],\n            a[2].value,\n            self.uintVars[keccak256('currentTotalTips')] -\n                (self.uintVars[keccak256('currentTotalTips')] % 5),\n            self.currentChallenge\n        );\n\n        //update the total supply\n        self.uintVars[keccak256('total_supply')] +=\n            self.uintVars[keccak256('devShare')] +\n            self.uintVars[keccak256('currentMinerReward')] *\n            5;\n\n        //Save the official(finalValue), timestamp of it, 5 miners and their submitted values for it, and its block number\n        _request.finalValues[\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        ] = a[2].value;\n        _request.requestTimestamps.push(\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        );\n        //these are miners by timestamp\n        _request.minersByValue[\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        ] = [a[0].miner, a[1].miner, a[2].miner, a[3].miner, a[4].miner];\n        _request.valuesByTimestamp[\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        ] = [a[0].value, a[1].value, a[2].value, a[3].value, a[4].value];\n        _request.minedBlockNum[\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        ] = block.number;\n        //map the timeOfLastValue to the requestId that was just mined\n\n        self.requestIdByTimestamp[\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        ] = _requestId;\n        //add timeOfLastValue to the newValueTimestamps array\n        self.newValueTimestamps.push(\n            self.uintVars[keccak256('timeOfLastNewValue')]\n        );\n        //re-start the count for the slot progress to zero before the new request mining starts\n        self.uintVars[keccak256('slotProgress')] = 0;\n        self.uintVars[keccak256('currentRequestId')] = ZapGettersLibrary\n            .getTopRequestID(self);\n        //if the currentRequestId is not zero(currentRequestId exists/something is being mined) select the requestId with the hightest payout\n        //else wait for a new tip to mine\n        if (self.uintVars[keccak256('currentRequestId')] > 0) {\n            //Update the current request to be mined to the requestID with the highest payout\n            self.uintVars[keccak256('currentTotalTips')] = self\n                .requestDetails[self.uintVars[keccak256('currentRequestId')]]\n                .apiUintVars[keccak256('totalTip')];\n            //Remove the currentRequestId/onDeckRequestId from the requestQ array containing the rest of the 50 requests\n            self.requestQ[\n                self\n                    .requestDetails[\n                        self.uintVars[keccak256('currentRequestId')]\n                    ]\n                    .apiUintVars[keccak256('requestQPosition')]\n            ] = 0;\n\n            //unmap the currentRequestId/onDeckRequestId from the requestIdByRequestQIndex\n            self.requestIdByRequestQIndex[\n                self\n                    .requestDetails[\n                        self.uintVars[keccak256('currentRequestId')]\n                    ]\n                    .apiUintVars[keccak256('requestQPosition')]\n            ] = 0;\n\n            //Remove the requestQposition for the currentRequestId/onDeckRequestId since it will be mined next\n            self\n                .requestDetails[self.uintVars[keccak256('currentRequestId')]]\n                .apiUintVars[keccak256('requestQPosition')] = 0;\n\n            //Reset the requestId TotalTip to 0 for the currentRequestId/onDeckRequestId since it will be mined next\n            //and the tip is going to the current timestamp miners. The tip for the API needs to be reset to zero\n            self\n                .requestDetails[self.uintVars[keccak256('currentRequestId')]]\n                .apiUintVars[keccak256('totalTip')] = 0;\n\n            //gets the max tip in the in the requestQ[51] array and its index within the array??\n            uint256 newRequestId = ZapGettersLibrary.getTopRequestID(self);\n            //Issue the the next challenge\n            self.currentChallenge = keccak256(\n                abi.encodePacked(\n                    _nonce,\n                    self.currentChallenge,\n                    blockhash(block.number - 1)\n                )\n            ); // Save hash for next proof\n            emit NewChallenge(\n                self.currentChallenge,\n                self.uintVars[keccak256('currentRequestId')],\n                self.uintVars[keccak256('difficulty')],\n                self\n                    .requestDetails[\n                        self.uintVars[keccak256('currentRequestId')]\n                    ]\n                    .apiUintVars[keccak256('granularity')],\n                self\n                    .requestDetails[\n                        self.uintVars[keccak256('currentRequestId')]\n                    ]\n                    .queryString,\n                self.uintVars[keccak256('currentTotalTips')]\n            );\n            emit NewRequestOnDeck(\n                newRequestId,\n                self.requestDetails[newRequestId].queryString,\n                self.requestDetails[newRequestId].queryHash,\n                self.requestDetails[newRequestId].apiUintVars[\n                    keccak256('totalTip')\n                ]\n            );\n        } else {\n            self.uintVars[keccak256('currentTotalTips')] = 0;\n            self.currentChallenge = '';\n        }\n    }\n\n    /**\n     * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\n     * @param _nonce uint submitted by miner\n     * @param _requestId the apiId being mined\n     * @param _value of api query\n     */\n    function submitMiningSolution(\n        ZapStorage.ZapStorageStruct storage self,\n        string memory _nonce,\n        uint256 _requestId,\n        uint256 _value\n    ) public {\n        //requre miner is staked\n        require(self.stakerDetails[msg.sender].currentStatus == 1, \"Miner is not staked\");\n\n        //Check the miner is submitting the pow for the current request Id\n        require(_requestId == self.uintVars[keccak256('currentRequestId')], \"The solution submitted is not for the current request ID\");\n\n        //Saving the challenge information as unique by using the msg.sender\n        require(\n            uint256(\n                sha256(\n                    abi.encodePacked(\n                        ripemd160(\n                            abi.encodePacked(\n                                keccak256(\n                                    abi.encodePacked(\n                                        self.currentChallenge,\n                                        msg.sender,\n                                        _nonce\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            ) %\n                self.uintVars[keccak256('difficulty')] ==\n                0\n            , \"Challenge info is not unique\"\n        );\n\n        //Make sure the miner does not submit a value more than once\n        require(self.minersByChallenge[self.currentChallenge][msg.sender] == false, \"Miner has already submitted a value\");\n\n        // Set miner reward to zero to prevent it from giving rewards before a block is mined\n        self.uintVars[keccak256('currentMinerReward')] = 0;\n\n        //Save the miner and value received\n        self\n            .currentMiners[self.uintVars[keccak256('slotProgress')]]\n            .value = _value;\n        self.currentMiners[self.uintVars[keccak256('slotProgress')]].miner = msg\n            .sender;\n\n        //Add to the count how many values have been submitted, since only 5 are taken per request\n        self.uintVars[keccak256('slotProgress')]++;\n\n        //Update the miner status to true once they submit a value so they don't submit more than once\n        self.minersByChallenge[self.currentChallenge][msg.sender] = true;\n\n        emit NonceSubmitted(\n            msg.sender,\n            _nonce,\n            _requestId,\n            _value,\n            self.currentChallenge\n        );\n\n        //If 5 values have been received, adjust the difficulty otherwise sort the values until 5 are received\n        if (self.uintVars[keccak256('slotProgress')] == 5) {\n            newBlock(self, _nonce, _requestId);\n        }\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.5.16;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call.value(value)(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/zap-miner/Vault.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport './libraries/SafeMathM.sol';\nimport './ZapMaster.sol';\n\ncontract Vault {\n    using SafeMathM for uint256;\n\n    address public zapToken;\n    ZapMaster public zapMaster;\n    mapping(address => uint256) private balances;\n\n    uint256 constant private MAX_UINT = 2**256 - 1;\n\n    constructor (address token, address master) public {\n        zapToken = token;\n        zapMaster = ZapMaster(address(uint160(master)));\n        \n        token.call(abi.encodeWithSignature(\"approve(address,uint256)\", master, MAX_UINT));\n    }\n\n    function increaseApproval() public returns (bool) {\n        (bool s, bytes memory balance) = zapToken.call(abi.encodeWithSignature(\"allowance(address,address)\", address(this), zapMaster));\n        uint256 amount = MAX_UINT.sub(toUint256(balance, 0));\n        (bool success, bytes memory data) = zapToken.call(abi.encodeWithSignature(\"increaseApproval(address,uint256)\", zapMaster, amount));\n        return success;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function deposit(address userAddress, uint256 value) public {\n        require(userAddress != address(0), \"The zero address does not own a vault.\");\n        require(msg.sender == address(zapMaster), \"Only Zap contract accessible\");\n        balances[userAddress] = balances[userAddress].add(value);\n    }\n\n    function withdraw(address userAddress, uint256 value) public {\n        require(userAddress != address(0), \"The zero address does not own a vault.\");\n        require(msg.sender == address(zapMaster), \"Only Zap contract accessible\");\n        require(userBalance(userAddress) >= value, \"Your balance is insufficient.\");\n        balances[userAddress] = balances[userAddress].sub(value);\n    }\n\n    function userBalance(address userAddress) public view returns (uint256 balance) {\n        return balances[userAddress];\n    }\n}"
    },
    "contracts/zap-miner/libraries/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.5.16;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/Utilities.sol": {
      "content": "pragma solidity =0.5.16;\n\n//Functions for retrieving min and Max in 51 length array (requestQ)\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\n\nlibrary Utilities {\n    /// @dev Returns the minimum value and position in an array.\n    //@note IT IGNORES THE 0 INDEX\n    function getMin(uint256[51] memory arr)\n        internal\n        pure\n        returns (uint256 min, uint256 minIndex)\n    {\n        assembly {\n            minIndex := 50\n            min := mload(add(arr, mul(minIndex, 0x20)))\n            for {\n                let i := 49\n            } gt(i, 0) {\n                i := sub(i, 1)\n            } {\n                let item := mload(add(arr, mul(i, 0x20)))\n                if lt(item, min) {\n                    min := item\n                    minIndex := i\n                }\n            }\n        }\n    }\n\n    // function getMin(uint[51] memory data) internal pure returns(uint256 minimal,uint minIndex) {\n    //       minIndex = data.length - 1;\n    //       minimal = data[minIndex];\n    //       for(uint i = data.length-1;i > 0;i--) {\n    //           if(data[i] < minimal) {\n    //               minimal = data[i];\n    //               minIndex = i;\n    //           }\n    //       }\n    // }\n\n    function getMax(uint256[51] memory arr)\n        internal\n        pure\n        returns (uint256 max, uint256 maxIndex)\n    {\n        assembly {\n            for {\n                let i := 0\n            } lt(i, 51) {\n                i := add(i, 1)\n            } {\n                let item := mload(add(arr, mul(i, 0x20)))\n                if lt(max, item) {\n                    max := item\n                    maxIndex := i\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/zap-miner/libraries/ZapGettersLibrary.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport './SafeMathM.sol';\nimport './ZapStorage.sol';\nimport './Utilities.sol';\n\n/**\n * @title Zap Getters Library\n * @dev This is the getter library for all variables in the Zap Token system. ZapGetters references this\n * libary for the getters logic\n */\nlibrary ZapGettersLibrary {\n    using SafeMathM for uint256;\n\n    event NewZapAddress(address _newZap); //emmited when a proposed fork is voted true\n\n    /*Functions*/\n\n    //The next two functions are onlyOwner functions.  For Zap to be truly decentralized, we will need to transfer the Deity to the 0 address.\n    //Only needs to be in library\n    /**\n     * @dev This function allows us to set a new Deity (or remove it)\n     * @param _newDeity address of the new Deity of the zap system\n     */\n    function changeDeity(\n        ZapStorage.ZapStorageStruct storage self,\n        address _newDeity\n    ) internal {\n        require(self.addressVars[keccak256('_deity')] == msg.sender);\n        self.addressVars[keccak256('_deity')] = _newDeity;\n    }\n\n    //Only needs to be in library\n    /**\n     * @dev This function allows the deity to upgrade the Zap System\n     * @param _zapContract address of new updated ZapCore contract\n     */\n    function changeZapContract(\n        ZapStorage.ZapStorageStruct storage self,\n        address _zapContract\n    ) internal {\n        require(self.addressVars[keccak256('_deity')] == msg.sender);\n        self.addressVars[keccak256('zapContract')] = _zapContract;\n        emit NewZapAddress(_zapContract);\n    }\n\n    function changeVaultContract(\n        ZapStorage.ZapStorageStruct storage self,\n        address _vaultAddress\n    ) internal {\n        require(self.addressVars[keccak256('_owner')] == msg.sender);\n        self.addressVars[keccak256('_vault')] = _vaultAddress;\n    }\n\n    /*Zap Getters*/\n\n    /**\n     * @dev This function tells you if a given challenge has been completed by a given miner\n     * @param _challenge the challenge to search for\n     * @param _miner address that you want to know if they solved the challenge\n     * @return true if the _miner address provided solved the\n     */\n    function didMine(\n        ZapStorage.ZapStorageStruct storage self,\n        bytes32 _challenge,\n        address _miner\n    ) internal view returns (bool) {\n        return self.minersByChallenge[_challenge][_miner];\n    }\n\n    /**\n     * @dev Checks if an address voted in a dispute\n     * @param _disputeId to look up\n     * @param _address of voting party to look up\n     * @return bool of whether or not party voted\n     */\n    function didVote(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _disputeId,\n        address _address\n    ) internal view returns (bool) {\n        return self.disputesById[_disputeId].voted[_address];\n    }\n\n    /**\n     * @dev allows Zap to read data from the addressVars mapping\n     * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\n     * These are examples of how the variables are saved within other functions:\n     * addressVars[keccak256(\"_owner\")]\n     * addressVars[keccak256(\"zapContract\")]\n     */\n    function getAddressVars(\n        ZapStorage.ZapStorageStruct storage self,\n        bytes32 _data\n    ) internal view returns (address) {\n        return self.addressVars[_data];\n    }\n\n    /**\n     * @dev Gets all dispute variables\n     * @param _disputeId to look up\n     * @return bytes32 hash of dispute\n     * @return bool executed where true if it has been voted on\n     * @return bool disputeVotePassed\n     * @return bool isPropFork true if the dispute is a proposed fork\n     * @return address of reportedMiner\n     * @return address of reportingParty\n     * @return address of proposedForkAddress\n     * @return uint of requestId\n     * @return uint of timestamp\n     * @return uint of value\n     * @return uint of minExecutionDate\n     * @return uint of numberOfVotes\n     * @return uint of blocknumber\n     * @return uint of minerSlot\n     * @return uint of quorum\n     * @return uint of fee\n     * @return int count of the current tally\n     */\n    function getAllDisputeVars(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _disputeId\n    )\n        internal\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        )\n    {\n        ZapStorage.Dispute storage disp = self.disputesById[_disputeId];\n        return (\n            disp.hash,\n            disp.executed,\n            disp.disputeVotePassed,\n            disp.isPropFork,\n            disp.reportedMiner,\n            disp.reportingParty,\n            disp.proposedForkAddress,\n            [  //all these keys are being being calculated\n                disp.disputeUintVars[keccak256('requestId')],\n                disp.disputeUintVars[keccak256('timestamp')],\n                disp.disputeUintVars[keccak256('value')],\n                disp.disputeUintVars[keccak256('minExecutionDate')],\n                disp.disputeUintVars[keccak256('numberOfVotes')],\n                disp.disputeUintVars[keccak256('blockNumber')],\n                disp.disputeUintVars[keccak256('minerSlot')],\n                disp.disputeUintVars[keccak256('quorum')],\n                disp.disputeUintVars[keccak256('fee')]\n            ],\n            disp.tally\n        );\n    }\n\n    /**\n     * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\n     * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\n     */\n    function getCurrentVariables(ZapStorage.ZapStorageStruct storage self)\n        internal\n        view\n        returns (\n            bytes32,\n            uint256,\n            uint256,\n            string memory,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            self.currentChallenge, //these keys below are being calculated\n            self.uintVars[keccak256('currentRequestId')],\n            self.uintVars[keccak256('difficulty')],\n            self\n                .requestDetails[self.uintVars[keccak256('currentRequestId')]]\n                .queryString,\n            self\n                .requestDetails[self.uintVars[keccak256('currentRequestId')]]\n                .apiUintVars[keccak256('granularity')],\n            self\n                .requestDetails[self.uintVars[keccak256('currentRequestId')]]\n                .apiUintVars[keccak256('totalTip')]\n        );\n    }\n\n    /**\n     * @dev Checks if a given hash of miner,requestId has been disputed\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\n     * @return uint disputeId\n     */\n    function getDisputeIdByDisputeHash(\n        ZapStorage.ZapStorageStruct storage self,\n        bytes32 _hash\n    ) internal view returns (uint256) {\n        return self.disputeIdByDisputeHash[_hash];\n    }\n\n    /**\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\n     * @param _disputeId is the dispute id;\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the disputeUintVars under the Dispute struct\n     * @return uint value for the bytes32 data submitted\n     */\n    function getDisputeUintVars(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _disputeId,\n        bytes32 _data\n    ) internal view returns (uint256) {\n        return self.disputesById[_disputeId].disputeUintVars[_data];\n    }\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @return value for timestamp of last proof of work submited\n     * @return true if the is a timestamp for the lastNewValue\n     */\n    function getLastNewValue(ZapStorage.ZapStorageStruct storage self)\n        internal\n        view\n        returns (uint256, bool)\n    {\n        return (\n            retrieveData(\n                self, //more being calculated\n                self.requestIdByTimestamp[\n                    self.uintVars[keccak256('timeOfLastNewValue')]\n                ],\n                self.uintVars[keccak256('timeOfLastNewValue')]\n            ),\n            true\n        );\n    }\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @param _requestId being requested\n     * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\n     */\n    function getLastNewValueById(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId\n    ) internal view returns (uint256, bool) {\n        ZapStorage.Request storage _request = self.requestDetails[_requestId];\n        if (_request.requestTimestamps.length > 0) {\n            return (\n                retrieveData(\n                    self,\n                    _requestId,\n                    _request.requestTimestamps[\n                        _request.requestTimestamps.length - 1\n                    ]\n                ),\n                true\n            );\n        } else {\n            return (0, false);\n        }\n    }\n\n    /**\n     * @dev Gets blocknumber for mined timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up blocknumber\n     * @return uint of the blocknumber which the dispute was mined\n     */\n    function getMinedBlockNum(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return the 5 miners' addresses\n     */\n    function getMinersByRequestIdAndTimestamp(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId,\n        uint256 _timestamp\n    ) internal view returns (address[5] memory) {\n        return self.requestDetails[_requestId].minersByValue[_timestamp];\n    }\n\n    /**\n     * @dev Get the name of the token\n     * @return string of the token name\n     */\n    function getName(ZapStorage.ZapStorageStruct storage self)\n        internal\n        pure\n        returns (string memory)\n    {\n        return 'Zap BEP20';\n    }\n\n    /**\n     * @dev Counts the number of values that have been submited for the request\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\n     * request so far\n     * @param _requestId the requestId to look up\n     * @return uint count of the number of values received for the requestId\n     */\n    function getNewValueCountbyRequestId(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId\n    ) internal view returns (uint256) {\n        return self.requestDetails[_requestId].requestTimestamps.length;\n    }\n\n    /**\n     * @dev Getter function for the specified requestQ index\n     * @param _index to look up in the requestQ array\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByRequestQIndex(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _index\n    ) internal view returns (uint256) {\n        require(_index <= 50);\n        return self.requestIdByRequestQIndex[_index];\n    }\n\n    /**\n     * @dev Getter function for requestId based on timestamp\n     * @param _timestamp to check requestId\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByTimestamp(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        return self.requestIdByTimestamp[_timestamp];\n    }\n\n    /**\n     * @dev Getter function for requestId based on the qeuaryHash\n     * @param _queryHash hash(of string api and granularity) to check if a request already exists\n     * @return uint requestId\n     */\n    function getRequestIdByQueryHash(\n        ZapStorage.ZapStorageStruct storage self,\n        bytes32 _queryHash\n    ) internal view returns (uint256) {\n        return self.requestIdByQueryHash[_queryHash];\n    }\n\n    /**\n     * @dev Getter function for the requestQ array\n     * @return the requestQ arrray\n     */\n    function getRequestQ(ZapStorage.ZapStorageStruct storage self)\n        internal\n        view\n        returns (uint256[51] memory)\n    {\n        return self.requestQ;\n    }\n\n    /**\n     * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\n     * for the requestId specified\n     * @param _requestId to look up\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the apiUintVars under the requestDetails struct\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\n     */\n    function getRequestUintVars(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId,\n        bytes32 _data\n    ) internal view returns (uint256) {\n        return self.requestDetails[_requestId].apiUintVars[_data];\n    }\n\n    /**\n     * @dev Gets the API struct variables that are not mappings\n     * @param _requestId to look up\n     * @return string of api to query\n     * @return string of symbol of api to query\n     * @return bytes32 hash of string\n     * @return bytes32 of the granularity(decimal places) requested\n     * @return uint of index in requestQ array\n     * @return uint of current payout/tip for this requestId\n     */\n    function getRequestVars(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId\n    )\n        internal\n        view\n        returns (\n            string memory,\n            string memory,\n            bytes32,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ZapStorage.Request storage _request = self.requestDetails[_requestId];\n        return (\n            _request.queryString,\n            _request.dataSymbol,\n            _request.queryHash, //more to be calculated\n            _request.apiUintVars[keccak256('granularity')],\n            _request.apiUintVars[keccak256('requestQPosition')],\n            _request.apiUintVars[keccak256('totalTip')]\n        );\n    }\n\n    /**\n     * @dev This function allows users to retireve all information about a staker\n     * @param _staker address of staker inquiring about\n     * @return uint current state of staker\n     * @return uint startDate of staking\n     */\n    function getStakerInfo(\n        ZapStorage.ZapStorageStruct storage self,\n        address _staker\n    ) internal view returns (uint256, uint256) {\n        return (\n            self.stakerDetails[_staker].currentStatus,\n            self.stakerDetails[_staker].startDate\n        );\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestampt to look up miners for\n     * @return address[5] array of 5 addresses ofminers that mined the requestId\n     */\n    function getSubmissionsByTimestamp(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId,\n        uint256 _timestamp\n    ) internal view returns (uint256[5] memory) {\n        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\n    }\n\n    /**\n     * @dev Get the symbol of the token\n     * @return string of the token symbol\n     */\n    function getSymbol(ZapStorage.ZapStorageStruct storage self)\n        internal\n        pure\n        returns (string memory)\n    {\n        return 'ZAPB';\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _requestID is the requestId to look up\n     * @param _index is the value index to look up\n     * @return uint timestamp\n     */\n    function getTimestampbyRequestIDandIndex(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestID,\n        uint256 _index\n    ) internal view returns (uint256) {\n        return self.requestDetails[_requestID].requestTimestamps[_index];\n    }\n\n    /**\n     * @dev Getter for the variables saved under the ZapStorageStruct uintVars variable\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the uintVars under the ZapStorageStruct struct\n     * This is an example of how data is saved into the mapping within other functions:\n     * self.uintVars[keccak256(\"stakerCount\")]\n     * @return uint of specified variable\n     */\n    function getUintVar(ZapStorage.ZapStorageStruct storage self, bytes32 _data)\n        internal\n        view\n        returns (uint256)\n    {\n        return self.uintVars[_data];\n    }\n\n    /**\n     * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n     * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\n     */\n    function getVariablesOnDeck(ZapStorage.ZapStorageStruct storage self)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            string memory\n        )\n    {\n        uint256 newRequestId = getTopRequestID(self);\n        return (\n            newRequestId, //more being calculated\n            self.requestDetails[newRequestId].apiUintVars[\n                keccak256('totalTip')\n            ],\n            self.requestDetails[newRequestId].queryString\n        );\n    }\n\n    /**\n     * @dev Getter function for the request with highest payout. This function is used withing the getVariablesOnDeck function\n     * @return uint _requestId of request with highest payout at the time the function is called\n     */\n    function getTopRequestID(ZapStorage.ZapStorageStruct storage self)\n        internal\n        view\n        returns (uint256 _requestId)\n    {\n        uint256 _max;\n        uint256 _index;\n        (_max, _index) = Utilities.getMax(self.requestQ);\n        _requestId = self.requestIdByRequestQIndex[_index];\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return bool true if requestId/timestamp is under dispute\n     */\n    function isInDispute(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId,\n        uint256 _timestamp\n    ) internal view returns (bool) {\n        return self.requestDetails[_requestId].inDispute[_timestamp];\n    }\n\n    /**\n     * @dev Retreive value from oracle based on requestId/timestamp\n     * @param _requestId being requested\n     * @param _timestamp to retreive data/value from\n     * @return uint value for requestId/timestamp submitted\n     */\n    function retrieveData(\n        ZapStorage.ZapStorageStruct storage self,\n        uint256 _requestId,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        return self.requestDetails[_requestId].finalValues[_timestamp];\n    }\n\n    /**\n     * @dev Getter for the total_supply of oracle tokens\n     * @return uint total supply\n     */\n    function totalSupply(ZapStorage.ZapStorageStruct storage self)\n        internal\n        view\n        returns (uint256)\n    { //below is caculation\n        return self.uintVars[keccak256('total_supply')];\n    }\n}\n"
    },
    "contracts/zap-miner/ZapMaster.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport './ZapGetters.sol';\nimport './libraries/Address.sol';\n\n/**\n * @title Zap Master\n * @dev This is the Master contract with all zap getter functions and delegate call to Zap.\n * The logic for the functions on this contract is saved on the ZapGettersLibrary,\n * ZapGettersLibrary, and ZapStake\n */\ncontract ZapMaster is ZapGetters {\n    event NewZapAddress(address _newZap);\n    using Address for address;\n\n    address public owner;\n\n    /// @dev Throws if called by any contract other than latest designated caller\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'Only owner can transfer balance.');\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the original `zapStorageOwner` of the contract to the sender\n     * account, the zap contract to the Zap master address and owner to the Zap master owner address\n     * @param _zapContract is the address for the zap contract\n     */\n    constructor(address _zapContract, address tokenAddress)\n        public\n        ZapGetters(tokenAddress)\n    {\n        zap.init();\n        zap.addressVars[keccak256('_owner')] = msg.sender;\n        zap.addressVars[keccak256('_deity')] = msg.sender;\n        zap.addressVars[keccak256('zapContract')] = _zapContract;\n        // zap.addressVars[keccak256('zapTokenContract')] = tokenAddress;\n\n        owner = msg.sender;\n\n        emit NewZapAddress(_zapContract);\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @dev Only needs to be in library\n     * @param _newDeity the new Deity in the contract\n     */\n\n    function changeDeity(address _newDeity) external {\n        zap.changeDeity(_newDeity);\n    }\n\n    /**\n     * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\n     * @param _zapContract the address of the new Zap Contract\n     */\n    function changeZapContract(address _zapContract) external {\n        zap.changeZapContract(_zapContract);\n    }\n\n    /**\n     * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\n     * @param _vaultContract the address of the new Vault Contract\n     */\n    function changeVaultContract(address _vaultContract) external {\n        zap.changeVaultContract(_vaultContract);\n    }\n\n    /**\n     * @dev This is the fallback function that allows contracts to call the zap contract at the address stored\n     */\n    function() external payable {\n        address addr = zap.addressVars[keccak256('zapContract')];\n        bytes memory _calldata = msg.data;\n        assembly {\n            let result := delegatecall(\n                gas(),\n                addr,\n                add(_calldata, 0x20),\n                mload(_calldata),\n                0,\n                0\n            )\n            let size := returndatasize\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/zap-miner/ZapGetters.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport './libraries/SafeMathM.sol';\nimport './libraries/ZapStorage.sol';\nimport './libraries/ZapGettersLibrary.sol';\nimport './libraries/ZapStake.sol';\nimport '../token/ZapTokenBSC.sol';\n\n/**\n * @title Zap Getters\n * @dev Oracle contract with all zap getter functions. The logic for the functions on this contract\n * is saved on the ZapGettersLibrary, ZapGettersLibrary, and ZapStake\n */\ncontract ZapGetters {\n    using SafeMathM for uint256;\n\n    using ZapGettersLibrary for ZapStorage.ZapStorageStruct;\n    using ZapStake for ZapStorage.ZapStorageStruct;\n\n    ZapStorage.ZapStorageStruct internal zap;\n    ZapTokenBSC internal token;\n\n    constructor(address zapTokenBsc) public {\n        token = ZapTokenBSC(zapTokenBsc);\n        zap.addressVars[keccak256('zapTokenContract')] = zapTokenBsc;\n    }\n\n    /**\n     * @param _user address\n     * @param _spender address\n     * @return Returns the remaining allowance of tokens granted to the _spender from the _user\n     */\n    function allowance(address _user, address _spender)\n        public\n        view\n        returns (uint256)\n    {\n        //    return zap.allowance(_user,_spender);\n        return token.allowance(_user, _spender);\n    }\n\n    /**\n     * @dev Gets balance of owner specified\n     * @param _user is the owner address used to look up the balance\n     * @return Returns the balance associated with the passed in _user\n     */\n    function balanceOf(address _user) public view returns (uint256) {\n        // return zap.balanceOf(_user);\n        return token.balanceOf(_user);\n    }\n\n    /**\n     * @dev Queries the balance of _user at a specific _blockNumber\n     * @param _user The address from which the balance will be retrieved\n     * @param _blockNumber The block number when the balance is queried\n     * @return The balance at _blockNumber\n     */\n    // function balanceOfAt(address _user, uint _blockNumber) external view returns (uint) {\n    //     return zap.balanceOfAt(_user,_blockNumber);\n    // }\n\n    /**\n     * @dev This function tells you if a given challenge has been completed by a given miner\n     * @param _challenge the challenge to search for\n     * @param _miner address that you want to know if they solved the challenge\n     * @return true if the _miner address provided solved the\n     */\n    function didMine(bytes32 _challenge, address _miner)\n        external\n        view\n        returns (bool)\n    {\n        return zap.didMine(_challenge, _miner);\n    }\n\n    /**\n     * @dev Checks if an address voted in a given dispute\n     * @param _disputeId to look up\n     * @param _address to look up\n     * @return bool of whether or not party voted\n     */\n    function didVote(uint256 _disputeId, address _address)\n        external\n        view\n        returns (bool)\n    {\n        return zap.didVote(_disputeId, _address);\n    }\n\n    /**\n     * @dev allows Zap to read data from the addressVars mapping\n     * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\n     * These are examples of how the variables are saved within other functions:\n     * addressVars[keccak256(\"_owner\")]\n     * addressVars[keccak256(\"zapContract\")]\n     */\n    function getAddressVars(bytes32 _data) external view returns (address) {\n        return zap.getAddressVars(_data);\n    }\n\n    /**\n     * @dev Gets all dispute variables\n     * @param _disputeId to look up\n     * @return bytes32 hash of dispute\n     * @return bool executed where true if it has been voted on\n     * @return bool disputeVotePassed\n     * @return bool isPropFork true if the dispute is a proposed fork\n     * @return address of reportedMiner\n     * @return address of reportingParty\n     * @return address of proposedForkAddress\n     * @return uint of requestId\n     * @return uint of timestamp\n     * @return uint of value\n     * @return uint of minExecutionDate\n     * @return uint of numberOfVotes\n     * @return uint of blocknumber\n     * @return uint of minerSlot\n     * @return uint of quorum\n     * @return uint of fee\n     * @return int count of the current tally\n     */\n    function getAllDisputeVars(uint256 _disputeId)\n        public\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        )\n    {\n        return zap.getAllDisputeVars(_disputeId);\n    }\n\n    /**\n     * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\n     * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\n     */\n    function getCurrentVariables()\n        external\n        view\n        returns (\n            bytes32,\n            uint256,\n            uint256,\n            string memory,\n            uint256,\n            uint256\n        )\n    {\n        return zap.getCurrentVariables();\n    }\n\n    /**\n     * @dev Checks if a given hash of miner,requestId has been disputed\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\n     * @return uint disputeId\n     */\n    function getDisputeIdByDisputeHash(bytes32 _hash)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getDisputeIdByDisputeHash(_hash);\n    }\n\n    /**\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\n     * @param _disputeId is the dispute id;\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the disputeUintVars under the Dispute struct\n     * @return uint value for the bytes32 data submitted\n     */\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getDisputeUintVars(_disputeId, _data);\n    }\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @return value for timestamp of last proof of work submited\n     * @return true if the is a timestamp for the lastNewValue\n     */\n    function getLastNewValue() external view returns (uint256, bool) {\n        return zap.getLastNewValue();\n    }\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @param _requestId being requested\n     * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\n     */\n    function getLastNewValueById(uint256 _requestId)\n        external\n        view\n        returns (uint256, bool)\n    {\n        return zap.getLastNewValueById(_requestId);\n    }\n\n    /**\n     * @dev Gets blocknumber for mined timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up blocknumber\n     * @return uint of the blocknumber which the dispute was mined\n     */\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getMinedBlockNum(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return the 5 miners' addresses\n     */\n    function getMinersByRequestIdAndTimestamp(\n        uint256 _requestId,\n        uint256 _timestamp\n    ) external view returns (address[5] memory) {\n        return zap.getMinersByRequestIdAndTimestamp(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Get the name of the token\n     * return string of the token name\n     */\n    function getName() external view returns (string memory) {\n        return zap.getName();\n    }\n\n    /**\n     * @dev Counts the number of values that have been submited for the request\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\n     * request so far\n     * @param _requestId the requestId to look up\n     * @return uint count of the number of values received for the requestId\n     */\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getNewValueCountbyRequestId(_requestId);\n    }\n\n    /**\n     * @dev Getter function for the specified requestQ index\n     * @param _index to look up in the requestQ array\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByRequestQIndex(uint256 _index)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getRequestIdByRequestQIndex(_index);\n    }\n\n    /**\n     * @dev Getter function for requestId based on timestamp\n     * @param _timestamp to check requestId\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByTimestamp(uint256 _timestamp)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getRequestIdByTimestamp(_timestamp);\n    }\n\n    /**\n     * @dev Getter function for requestId based on the queryHash\n     * @param _request is the hash(of string api and granularity) to check if a request already exists\n     * @return uint requestId\n     */\n    function getRequestIdByQueryHash(bytes32 _request)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getRequestIdByQueryHash(_request);\n    }\n\n    /**\n     * @dev Getter function for the requestQ array\n     * @return the requestQ arrray\n     */\n    function getRequestQ() public view returns (uint256[51] memory) {\n        return zap.getRequestQ();\n    }\n\n    /**\n     * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\n     * for the requestId specified\n     * @param _requestId to look up\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the apiUintVars under the requestDetails struct\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\n     */\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getRequestUintVars(_requestId, _data);\n    }\n\n    /**\n     * @dev Gets the API struct variables that are not mappings\n     * @param _requestId to look up\n     * @return string of api to query\n     * @return string of symbol of api to query\n     * @return bytes32 hash of string\n     * @return bytes32 of the granularity(decimal places) requested\n     * @return uint of index in requestQ array\n     * @return uint of current payout/tip for this requestId\n     */\n    function getRequestVars(uint256 _requestId)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            bytes32,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return zap.getRequestVars(_requestId);\n    }\n\n    /**\n     * @dev This function allows users to retireve all information about a staker\n     * @param _staker address of staker inquiring about\n     * @return uint current state of staker\n     * @return uint startDate of staking\n     */\n    function getStakerInfo(address _staker)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return zap.getStakerInfo(_staker);\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestampt to look up miners for\n     * @return address[5] array of 5 addresses ofminers that mined the requestId\n     */\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256[5] memory)\n    {\n        return zap.getSubmissionsByTimestamp(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Get the symbol of the token\n     * return string of the token symbol\n     */\n    function getSymbol() external view returns (string memory) {\n        return zap.getSymbol();\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _requestID is the requestId to look up\n     * @param _index is the value index to look up\n     * @return uint timestamp\n     */\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.getTimestampbyRequestIDandIndex(_requestID, _index);\n    }\n\n    /**\n     * @dev Getter for the variables saved under the ZapStorageStruct uintVars variable\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the uintVars under the ZapStorageStruct struct\n     * This is an example of how data is saved into the mapping within other functions:\n     * self.uintVars[keccak256(\"stakerCount\")]\n     * @return uint of specified variable\n     */\n    function getUintVar(bytes32 _data) public view returns (uint256) {\n        return zap.getUintVar(_data);\n    }\n\n    /**\n     * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n     * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\n     */\n    function getVariablesOnDeck()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            string memory\n        )\n    {\n        return zap.getVariablesOnDeck();\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return bool true if requestId/timestamp is under dispute\n     */\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (bool)\n    {\n        return zap.isInDispute(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Retreive value from oracle based on timestamp\n     * @param _requestId being requested\n     * @param _timestamp to retreive data/value from\n     * @return value for timestamp submitted\n     */\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256)\n    {\n        return zap.retrieveData(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Getter for the total_supply of oracle tokens\n     * @return uint total supply\n     */\n    function totalTokenSupply() external view returns (uint256) {\n        return zap.totalSupply();\n        // return token.totalSupply;\n    }\n}\n"
    },
    "contracts/zap-miner/test/ZapMasterTest.sol": {
      "content": "pragma solidity =0.5.16;\n\nimport \"../ZapMaster.sol\";\n\ncontract ZapMasterTest is ZapMaster {\n    constructor(uint256 stakeAmount, address zapSol, address zapToken)\n        public\n        ZapMaster(zapSol, zapToken)\n    {\n        zap.uintVars[keccak256(\"stakeAmount\")] = stakeAmount;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}